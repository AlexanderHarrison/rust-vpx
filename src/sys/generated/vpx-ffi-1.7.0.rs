/* automatically generated by rust-bindgen */
use std::os::raw::*;
pub const VPX_IMAGE_ABI_VERSION: u32 = 4;
pub const VPX_IMG_FMT_PLANAR: u32 = 256;
pub const VPX_IMG_FMT_UV_FLIP: u32 = 512;
pub const VPX_IMG_FMT_HAS_ALPHA: u32 = 1024;
pub const VPX_IMG_FMT_HIGHBITDEPTH: u32 = 2048;
pub const VPX_PLANE_PACKED: u32 = 0;
pub const VPX_PLANE_Y: u32 = 0;
pub const VPX_PLANE_U: u32 = 1;
pub const VPX_PLANE_V: u32 = 2;
pub const VPX_PLANE_ALPHA: u32 = 3;
pub const VPX_CODEC_ABI_VERSION: u32 = 8;
pub const VPX_CODEC_CAP_DECODER: u32 = 1;
pub const VPX_CODEC_CAP_ENCODER: u32 = 2;
pub const VPX_CODEC_CAP_HIGHBITDEPTH: u32 = 4;
pub const VPX_TS_MAX_PERIODICITY: u32 = 16;
pub const VPX_TS_MAX_LAYERS: u32 = 5;
pub const MAX_PERIODICITY: u32 = 16;
pub const VPX_MAX_LAYERS: u32 = 12;
pub const MAX_LAYERS: u32 = 12;
pub const VPX_SS_MAX_LAYERS: u32 = 5;
pub const VPX_SS_DEFAULT_LAYERS: u32 = 1;
pub const VPX_ENCODER_ABI_VERSION: u32 = 14;
pub const VPX_CODEC_CAP_PSNR: u32 = 65536;
pub const VPX_CODEC_CAP_OUTPUT_PARTITION: u32 = 131072;
pub const VPX_CODEC_USE_PSNR: u32 = 65536;
pub const VPX_CODEC_USE_OUTPUT_PARTITION: u32 = 131072;
pub const VPX_CODEC_USE_HIGHBITDEPTH: u32 = 262144;
pub const VPX_FRAME_IS_KEY: u32 = 1;
pub const VPX_FRAME_IS_DROPPABLE: u32 = 2;
pub const VPX_FRAME_IS_INVISIBLE: u32 = 4;
pub const VPX_FRAME_IS_FRAGMENT: u32 = 8;
pub const VPX_ERROR_RESILIENT_DEFAULT: u32 = 1;
pub const VPX_ERROR_RESILIENT_PARTITIONS: u32 = 2;
pub const VPX_EFLAG_FORCE_KF: u32 = 1;
pub const VPX_DL_REALTIME: u32 = 1;
pub const VPX_DL_GOOD_QUALITY: u32 = 1000000;
pub const VPX_DL_BEST_QUALITY: u32 = 0;
pub const VP8_EFLAG_NO_REF_LAST: u32 = 65536;
pub const VP8_EFLAG_NO_REF_GF: u32 = 131072;
pub const VP8_EFLAG_NO_REF_ARF: u32 = 2097152;
pub const VP8_EFLAG_NO_UPD_LAST: u32 = 262144;
pub const VP8_EFLAG_NO_UPD_GF: u32 = 4194304;
pub const VP8_EFLAG_NO_UPD_ARF: u32 = 8388608;
pub const VP8_EFLAG_FORCE_GF: u32 = 524288;
pub const VP8_EFLAG_FORCE_ARF: u32 = 16777216;
pub const VP8_EFLAG_NO_UPD_ENTROPY: u32 = 1048576;
pub const VPX_MAXIMUM_WORK_BUFFERS: u32 = 8;
pub const VP9_MAXIMUM_REF_BUFFERS: u32 = 8;
pub const VPX_DECODER_ABI_VERSION: u32 = 11;
pub const VPX_CODEC_CAP_PUT_SLICE: u32 = 65536;
pub const VPX_CODEC_CAP_PUT_FRAME: u32 = 131072;
pub const VPX_CODEC_CAP_POSTPROC: u32 = 262144;
pub const VPX_CODEC_CAP_ERROR_CONCEALMENT: u32 = 524288;
pub const VPX_CODEC_CAP_INPUT_FRAGMENTS: u32 = 1048576;
pub const VPX_CODEC_CAP_FRAME_THREADING: u32 = 2097152;
pub const VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER: u32 = 4194304;
pub const VPX_CODEC_USE_POSTPROC: u32 = 65536;
pub const VPX_CODEC_USE_ERROR_CONCEALMENT: u32 = 131072;
pub const VPX_CODEC_USE_INPUT_FRAGMENTS: u32 = 262144;
pub const VPX_CODEC_USE_FRAME_THREADING: u32 = 524288;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_img_fmt {
  VPX_IMG_FMT_NONE = 0,
  VPX_IMG_FMT_RGB24 = 1,
  VPX_IMG_FMT_RGB32 = 2,
  VPX_IMG_FMT_RGB565 = 3,
  VPX_IMG_FMT_RGB555 = 4,
  VPX_IMG_FMT_UYVY = 5,
  VPX_IMG_FMT_YUY2 = 6,
  VPX_IMG_FMT_YVYU = 7,
  VPX_IMG_FMT_BGR24 = 8,
  VPX_IMG_FMT_RGB32_LE = 9,
  VPX_IMG_FMT_ARGB = 10,
  VPX_IMG_FMT_ARGB_LE = 11,
  VPX_IMG_FMT_RGB565_LE = 12,
  VPX_IMG_FMT_RGB555_LE = 13,
  VPX_IMG_FMT_YV12 = 769,
  VPX_IMG_FMT_I420 = 258,
  VPX_IMG_FMT_VPXYV12 = 771,
  VPX_IMG_FMT_VPXI420 = 260,
  VPX_IMG_FMT_I422 = 261,
  VPX_IMG_FMT_I444 = 262,
  VPX_IMG_FMT_I440 = 263,
  VPX_IMG_FMT_444A = 1286,
  VPX_IMG_FMT_I42016 = 2306,
  VPX_IMG_FMT_I42216 = 2309,
  VPX_IMG_FMT_I44416 = 2310,
  VPX_IMG_FMT_I44016 = 2311,
}
pub use self::vpx_img_fmt as vpx_img_fmt_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_color_space {
  VPX_CS_UNKNOWN = 0,
  VPX_CS_BT_601 = 1,
  VPX_CS_BT_709 = 2,
  VPX_CS_SMPTE_170 = 3,
  VPX_CS_SMPTE_240 = 4,
  VPX_CS_BT_2020 = 5,
  VPX_CS_RESERVED = 6,
  VPX_CS_SRGB = 7,
}
pub use self::vpx_color_space as vpx_color_space_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_color_range {
  VPX_CR_STUDIO_RANGE = 0,
  VPX_CR_FULL_RANGE = 1,
}
pub use self::vpx_color_range as vpx_color_range_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image {
  pub fmt: vpx_img_fmt_t,
  pub cs: vpx_color_space_t,
  pub range: vpx_color_range_t,
  pub w: c_uint,
  pub h: c_uint,
  pub bit_depth: c_uint,
  pub d_w: c_uint,
  pub d_h: c_uint,
  pub r_w: c_uint,
  pub r_h: c_uint,
  pub x_chroma_shift: c_uint,
  pub y_chroma_shift: c_uint,
  pub planes: [*mut c_uchar; 4usize],
  pub stride: [c_int; 4usize],
  pub bps: c_int,
  pub user_priv: *mut c_void,
  pub img_data: *mut c_uchar,
  pub img_data_owner: c_int,
  pub self_allocd: c_int,
  pub fb_priv: *mut c_void,
}
pub type vpx_image_t = vpx_image;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image_rect {
  pub x: c_uint,
  pub y: c_uint,
  pub w: c_uint,
  pub h: c_uint,
}
pub type vpx_image_rect_t = vpx_image_rect;
extern "C" {
  pub fn vpx_img_alloc(
    img: *mut vpx_image_t,
    fmt: vpx_img_fmt_t,
    d_w: c_uint,
    d_h: c_uint,
    align: c_uint,
  ) -> *mut vpx_image_t;
  pub fn vpx_img_wrap(
    img: *mut vpx_image_t,
    fmt: vpx_img_fmt_t,
    d_w: c_uint,
    d_h: c_uint,
    align: c_uint,
    img_data: *mut c_uchar,
  ) -> *mut vpx_image_t;
  pub fn vpx_img_set_rect(
    img: *mut vpx_image_t,
    x: c_uint,
    y: c_uint,
    w: c_uint,
    h: c_uint,
  ) -> c_int;
  pub fn vpx_img_flip(img: *mut vpx_image_t);
  pub fn vpx_img_free(img: *mut vpx_image_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
  pub __mbstate8: [c_char; 128usize],
  pub _mbstateL: c_longlong,
  _bindgen_union_align: [u64; 16usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_codec_err_t {
  VPX_CODEC_OK = 0,
  VPX_CODEC_ERROR = 1,
  VPX_CODEC_MEM_ERROR = 2,
  VPX_CODEC_ABI_MISMATCH = 3,
  VPX_CODEC_INCAPABLE = 4,
  VPX_CODEC_UNSUP_BITSTREAM = 5,
  VPX_CODEC_UNSUP_FEATURE = 6,
  VPX_CODEC_CORRUPT_FRAME = 7,
  VPX_CODEC_INVALID_PARAM = 8,
  VPX_CODEC_LIST_END = 9,
}
pub type vpx_codec_caps_t = c_long;
pub type vpx_codec_flags_t = c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_iface {
  _unused: [u8; 0],
}
pub type vpx_codec_iface_t = vpx_codec_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_priv {
  _unused: [u8; 0],
}
pub type vpx_codec_priv_t = vpx_codec_priv;
pub type vpx_codec_iter_t = *const c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vpx_codec_ctx {
  pub name: *const c_char,
  pub iface: *mut vpx_codec_iface_t,
  pub err: vpx_codec_err_t,
  pub err_detail: *const c_char,
  pub init_flags: vpx_codec_flags_t,
  pub config: vpx_codec_ctx__bindgen_ty_1,
  pub priv_: *mut vpx_codec_priv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vpx_codec_ctx__bindgen_ty_1 {
  pub dec: *const vpx_codec_dec_cfg,
  pub enc: *const vpx_codec_enc_cfg,
  pub raw: *const c_void,
  _bindgen_union_align: u64,
}
pub type vpx_codec_ctx_t = vpx_codec_ctx;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_bit_depth {
  VPX_BITS_8 = 8,
  VPX_BITS_10 = 10,
  VPX_BITS_12 = 12,
}
pub use self::vpx_bit_depth as vpx_bit_depth_t;
extern "C" {
  pub fn vpx_codec_version() -> c_int;
  pub fn vpx_codec_version_str() -> *const c_char;
  pub fn vpx_codec_version_extra_str() -> *const c_char;
  pub fn vpx_codec_build_config() -> *const c_char;
  pub fn vpx_codec_iface_name(iface: *mut vpx_codec_iface_t) -> *const c_char;
  pub fn vpx_codec_err_to_string(err: vpx_codec_err_t) -> *const c_char;
  pub fn vpx_codec_error(ctx: *mut vpx_codec_ctx_t) -> *const c_char;
  pub fn vpx_codec_error_detail(ctx: *mut vpx_codec_ctx_t) -> *const c_char;
  pub fn vpx_codec_destroy(ctx: *mut vpx_codec_ctx_t) -> vpx_codec_err_t;
  pub fn vpx_codec_get_caps(iface: *mut vpx_codec_iface_t) -> vpx_codec_caps_t;
  pub fn vpx_codec_control_(ctx: *mut vpx_codec_ctx_t, ctrl_id: c_int, ...) -> vpx_codec_err_t;
}
pub const vp8_com_control_id_VP8_SET_REFERENCE: vp8_com_control_id = 1;
pub const vp8_com_control_id_VP8_COPY_REFERENCE: vp8_com_control_id = 2;
pub const vp8_com_control_id_VP8_SET_POSTPROC: vp8_com_control_id = 3;
pub const vp8_com_control_id_VP8_SET_DBG_COLOR_REF_FRAME: vp8_com_control_id = 4;
pub const vp8_com_control_id_VP8_SET_DBG_COLOR_MB_MODES: vp8_com_control_id = 5;
pub const vp8_com_control_id_VP8_SET_DBG_COLOR_B_MODES: vp8_com_control_id = 6;
pub const vp8_com_control_id_VP8_SET_DBG_DISPLAY_MV: vp8_com_control_id = 7;
pub const vp8_com_control_id_VP9_GET_REFERENCE: vp8_com_control_id = 128;
pub const vp8_com_control_id_VP8_COMMON_CTRL_ID_MAX: vp8_com_control_id = 129;
pub const vp8_com_control_id_VP8_DECODER_CTRL_ID_START: vp8_com_control_id = 256;
pub type vp8_com_control_id = u32;
pub const vp8_postproc_level_VP8_NOFILTERING: vp8_postproc_level = 0;
pub const vp8_postproc_level_VP8_DEBLOCK: vp8_postproc_level = 1;
pub const vp8_postproc_level_VP8_DEMACROBLOCK: vp8_postproc_level = 2;
pub const vp8_postproc_level_VP8_ADDNOISE: vp8_postproc_level = 4;
pub const vp8_postproc_level_VP8_DEBUG_TXT_FRAME_INFO: vp8_postproc_level = 8;
pub const vp8_postproc_level_VP8_DEBUG_TXT_MBLK_MODES: vp8_postproc_level = 16;
pub const vp8_postproc_level_VP8_DEBUG_TXT_DC_DIFF: vp8_postproc_level = 32;
pub const vp8_postproc_level_VP8_DEBUG_TXT_RATE_INFO: vp8_postproc_level = 64;
pub const vp8_postproc_level_VP8_MFQE: vp8_postproc_level = 1024;
pub type vp8_postproc_level = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vp8_postproc_cfg {
  pub post_proc_flag: c_int,
  pub deblocking_level: c_int,
  pub noise_level: c_int,
}
pub type vp8_postproc_cfg_t = vp8_postproc_cfg;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_ref_frame_type {
  VP8_LAST_FRAME = 1,
  VP8_GOLD_FRAME = 2,
  VP8_ALTR_FRAME = 4,
}
pub use self::vpx_ref_frame_type as vpx_ref_frame_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_ref_frame {
  pub frame_type: vpx_ref_frame_type_t,
  pub img: vpx_image_t,
}
pub type vpx_ref_frame_t = vpx_ref_frame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vp9_ref_frame {
  pub idx: c_int,
  pub img: vpx_image_t,
}
pub type vp9_ref_frame_t = vp9_ref_frame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_fixed_buf {
  pub buf: *mut c_void,
  pub sz: usize,
}
pub type vpx_fixed_buf_t = vpx_fixed_buf;
pub type vpx_codec_pts_t = i64;
pub type vpx_codec_frame_flags_t = u32;
pub type vpx_codec_er_flags_t = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_codec_cx_pkt_kind {
  VPX_CODEC_CX_FRAME_PKT = 0,
  VPX_CODEC_STATS_PKT = 1,
  VPX_CODEC_FPMB_STATS_PKT = 2,
  VPX_CODEC_PSNR_PKT = 3,
  VPX_CODEC_CUSTOM_PKT = 256,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vpx_codec_cx_pkt {
  pub kind: vpx_codec_cx_pkt_kind,
  pub data: vpx_codec_cx_pkt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vpx_codec_cx_pkt__bindgen_ty_1 {
  pub frame: vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1,
  pub twopass_stats: vpx_fixed_buf_t,
  pub firstpass_mb_stats: vpx_fixed_buf_t,
  pub psnr: vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt,
  pub raw: vpx_fixed_buf_t,
  pub pad: [c_char; 124usize],
  _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1 {
  pub buf: *mut c_void,
  pub sz: usize,
  pub pts: vpx_codec_pts_t,
  pub duration: c_ulong,
  pub flags: vpx_codec_frame_flags_t,
  pub partition_id: c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt {
  pub samples: [c_uint; 4usize],
  pub sse: [u64; 4usize],
  pub psnr: [f64; 4usize],
}
pub type vpx_codec_cx_pkt_t = vpx_codec_cx_pkt;
pub type vpx_codec_enc_output_cx_pkt_cb_fn_t = ::std::option::Option<
  unsafe extern "C" fn(pkt: *mut vpx_codec_cx_pkt_t, user_data: *mut c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_enc_output_cx_cb_pair {
  pub output_cx_pkt: vpx_codec_enc_output_cx_pkt_cb_fn_t,
  pub user_priv: *mut c_void,
}
pub type vpx_codec_priv_output_cx_pkt_cb_pair_t = vpx_codec_enc_output_cx_cb_pair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_rational {
  pub num: c_int,
  pub den: c_int,
}
pub type vpx_rational_t = vpx_rational;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_enc_pass {
  VPX_RC_ONE_PASS = 0,
  VPX_RC_FIRST_PASS = 1,
  VPX_RC_LAST_PASS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_rc_mode {
  VPX_VBR = 0,
  VPX_CBR = 1,
  VPX_CQ = 2,
  VPX_Q = 3,
}
pub const vpx_kf_mode_VPX_KF_DISABLED: vpx_kf_mode = vpx_kf_mode::VPX_KF_FIXED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_kf_mode {
  VPX_KF_FIXED = 0,
  VPX_KF_AUTO = 1,
}
pub type vpx_enc_frame_flags_t = c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_enc_cfg {
  pub g_usage: c_uint,
  pub g_threads: c_uint,
  pub g_profile: c_uint,
  pub g_w: c_uint,
  pub g_h: c_uint,
  pub g_bit_depth: vpx_bit_depth_t,
  pub g_input_bit_depth: c_uint,
  pub g_timebase: vpx_rational,
  pub g_error_resilient: vpx_codec_er_flags_t,
  pub g_pass: vpx_enc_pass,
  pub g_lag_in_frames: c_uint,
  pub rc_dropframe_thresh: c_uint,
  pub rc_resize_allowed: c_uint,
  pub rc_scaled_width: c_uint,
  pub rc_scaled_height: c_uint,
  pub rc_resize_up_thresh: c_uint,
  pub rc_resize_down_thresh: c_uint,
  pub rc_end_usage: vpx_rc_mode,
  pub rc_twopass_stats_in: vpx_fixed_buf_t,
  pub rc_firstpass_mb_stats_in: vpx_fixed_buf_t,
  pub rc_target_bitrate: c_uint,
  pub rc_min_quantizer: c_uint,
  pub rc_max_quantizer: c_uint,
  pub rc_undershoot_pct: c_uint,
  pub rc_overshoot_pct: c_uint,
  pub rc_buf_sz: c_uint,
  pub rc_buf_initial_sz: c_uint,
  pub rc_buf_optimal_sz: c_uint,
  pub rc_2pass_vbr_bias_pct: c_uint,
  pub rc_2pass_vbr_minsection_pct: c_uint,
  pub rc_2pass_vbr_maxsection_pct: c_uint,
  pub rc_2pass_vbr_corpus_complexity: c_uint,
  pub kf_mode: vpx_kf_mode,
  pub kf_min_dist: c_uint,
  pub kf_max_dist: c_uint,
  pub ss_number_layers: c_uint,
  pub ss_enable_auto_alt_ref: [c_int; 5usize],
  pub ss_target_bitrate: [c_uint; 5usize],
  pub ts_number_layers: c_uint,
  pub ts_target_bitrate: [c_uint; 5usize],
  pub ts_rate_decimator: [c_uint; 5usize],
  pub ts_periodicity: c_uint,
  pub ts_layer_id: [c_uint; 16usize],
  pub layer_target_bitrate: [c_uint; 12usize],
  pub temporal_layering_mode: c_int,
}
pub type vpx_codec_enc_cfg_t = vpx_codec_enc_cfg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_svc_parameters {
  pub max_quantizers: [c_int; 12usize],
  pub min_quantizers: [c_int; 12usize],
  pub scaling_factor_num: [c_int; 12usize],
  pub scaling_factor_den: [c_int; 12usize],
  pub speed_per_layer: [c_int; 12usize],
  pub temporal_layering_mode: c_int,
}
pub type vpx_svc_extra_cfg_t = vpx_svc_parameters;
extern "C" {
  pub fn vpx_codec_enc_init_ver(
    ctx: *mut vpx_codec_ctx_t,
    iface: *mut vpx_codec_iface_t,
    cfg: *const vpx_codec_enc_cfg_t,
    flags: vpx_codec_flags_t,
    ver: c_int,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_enc_init_multi_ver(
    ctx: *mut vpx_codec_ctx_t,
    iface: *mut vpx_codec_iface_t,
    cfg: *mut vpx_codec_enc_cfg_t,
    num_enc: c_int,
    flags: vpx_codec_flags_t,
    dsf: *mut vpx_rational_t,
    ver: c_int,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_enc_config_default(
    iface: *mut vpx_codec_iface_t,
    cfg: *mut vpx_codec_enc_cfg_t,
    reserved: c_uint,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_enc_config_set(
    ctx: *mut vpx_codec_ctx_t,
    cfg: *const vpx_codec_enc_cfg_t,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_get_global_headers(ctx: *mut vpx_codec_ctx_t) -> *mut vpx_fixed_buf_t;
  pub fn vpx_codec_encode(
    ctx: *mut vpx_codec_ctx_t,
    img: *const vpx_image_t,
    pts: vpx_codec_pts_t,
    duration: c_ulong,
    flags: vpx_enc_frame_flags_t,
    deadline: c_ulong,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_set_cx_data_buf(
    ctx: *mut vpx_codec_ctx_t,
    buf: *const vpx_fixed_buf_t,
    pad_before: c_uint,
    pad_after: c_uint,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_get_cx_data(
    ctx: *mut vpx_codec_ctx_t,
    iter: *mut vpx_codec_iter_t,
  ) -> *const vpx_codec_cx_pkt_t;
  pub fn vpx_codec_get_preview_frame(ctx: *mut vpx_codec_ctx_t) -> *const vpx_image_t;
  pub static mut vpx_codec_vp8_cx_algo: vpx_codec_iface_t;
  pub fn vpx_codec_vp8_cx() -> *mut vpx_codec_iface_t;
  pub static mut vpx_codec_vp9_cx_algo: vpx_codec_iface_t;
  pub fn vpx_codec_vp9_cx() -> *mut vpx_codec_iface_t;
}
pub const vp8e_enc_control_id_VP8E_SET_ROI_MAP: vp8e_enc_control_id = 8;
pub const vp8e_enc_control_id_VP8E_SET_ACTIVEMAP: vp8e_enc_control_id = 9;
pub const vp8e_enc_control_id_VP8E_SET_SCALEMODE: vp8e_enc_control_id = 11;
pub const vp8e_enc_control_id_VP8E_SET_CPUUSED: vp8e_enc_control_id = 13;
pub const vp8e_enc_control_id_VP8E_SET_ENABLEAUTOALTREF: vp8e_enc_control_id = 14;
pub const vp8e_enc_control_id_VP8E_SET_NOISE_SENSITIVITY: vp8e_enc_control_id = 15;
pub const vp8e_enc_control_id_VP8E_SET_SHARPNESS: vp8e_enc_control_id = 16;
pub const vp8e_enc_control_id_VP8E_SET_STATIC_THRESHOLD: vp8e_enc_control_id = 17;
pub const vp8e_enc_control_id_VP8E_SET_TOKEN_PARTITIONS: vp8e_enc_control_id = 18;
pub const vp8e_enc_control_id_VP8E_GET_LAST_QUANTIZER: vp8e_enc_control_id = 19;
pub const vp8e_enc_control_id_VP8E_GET_LAST_QUANTIZER_64: vp8e_enc_control_id = 20;
pub const vp8e_enc_control_id_VP8E_SET_ARNR_MAXFRAMES: vp8e_enc_control_id = 21;
pub const vp8e_enc_control_id_VP8E_SET_ARNR_STRENGTH: vp8e_enc_control_id = 22;
pub const vp8e_enc_control_id_VP8E_SET_ARNR_TYPE: vp8e_enc_control_id = 23;
pub const vp8e_enc_control_id_VP8E_SET_TUNING: vp8e_enc_control_id = 24;
pub const vp8e_enc_control_id_VP8E_SET_CQ_LEVEL: vp8e_enc_control_id = 25;
pub const vp8e_enc_control_id_VP8E_SET_MAX_INTRA_BITRATE_PCT: vp8e_enc_control_id = 26;
pub const vp8e_enc_control_id_VP8E_SET_FRAME_FLAGS: vp8e_enc_control_id = 27;
pub const vp8e_enc_control_id_VP9E_SET_MAX_INTER_BITRATE_PCT: vp8e_enc_control_id = 28;
pub const vp8e_enc_control_id_VP9E_SET_GF_CBR_BOOST_PCT: vp8e_enc_control_id = 29;
pub const vp8e_enc_control_id_VP8E_SET_TEMPORAL_LAYER_ID: vp8e_enc_control_id = 30;
pub const vp8e_enc_control_id_VP8E_SET_SCREEN_CONTENT_MODE: vp8e_enc_control_id = 31;
pub const vp8e_enc_control_id_VP9E_SET_LOSSLESS: vp8e_enc_control_id = 32;
pub const vp8e_enc_control_id_VP9E_SET_TILE_COLUMNS: vp8e_enc_control_id = 33;
pub const vp8e_enc_control_id_VP9E_SET_TILE_ROWS: vp8e_enc_control_id = 34;
pub const vp8e_enc_control_id_VP9E_SET_FRAME_PARALLEL_DECODING: vp8e_enc_control_id = 35;
pub const vp8e_enc_control_id_VP9E_SET_AQ_MODE: vp8e_enc_control_id = 36;
pub const vp8e_enc_control_id_VP9E_SET_FRAME_PERIODIC_BOOST: vp8e_enc_control_id = 37;
pub const vp8e_enc_control_id_VP9E_SET_NOISE_SENSITIVITY: vp8e_enc_control_id = 38;
pub const vp8e_enc_control_id_VP9E_SET_SVC: vp8e_enc_control_id = 39;
pub const vp8e_enc_control_id_VP9E_SET_SVC_PARAMETERS: vp8e_enc_control_id = 40;
pub const vp8e_enc_control_id_VP9E_SET_SVC_LAYER_ID: vp8e_enc_control_id = 41;
pub const vp8e_enc_control_id_VP9E_SET_TUNE_CONTENT: vp8e_enc_control_id = 42;
pub const vp8e_enc_control_id_VP9E_GET_SVC_LAYER_ID: vp8e_enc_control_id = 43;
pub const vp8e_enc_control_id_VP9E_REGISTER_CX_CALLBACK: vp8e_enc_control_id = 44;
pub const vp8e_enc_control_id_VP9E_SET_COLOR_SPACE: vp8e_enc_control_id = 45;
pub const vp8e_enc_control_id_VP9E_SET_TEMPORAL_LAYERING_MODE: vp8e_enc_control_id = 46;
pub const vp8e_enc_control_id_VP9E_SET_MIN_GF_INTERVAL: vp8e_enc_control_id = 47;
pub const vp8e_enc_control_id_VP9E_SET_MAX_GF_INTERVAL: vp8e_enc_control_id = 48;
pub const vp8e_enc_control_id_VP9E_GET_ACTIVEMAP: vp8e_enc_control_id = 49;
pub const vp8e_enc_control_id_VP9E_SET_COLOR_RANGE: vp8e_enc_control_id = 50;
pub const vp8e_enc_control_id_VP9E_SET_SVC_REF_FRAME_CONFIG: vp8e_enc_control_id = 51;
pub const vp8e_enc_control_id_VP9E_SET_RENDER_SIZE: vp8e_enc_control_id = 52;
pub const vp8e_enc_control_id_VP9E_SET_TARGET_LEVEL: vp8e_enc_control_id = 53;
pub const vp8e_enc_control_id_VP9E_SET_ROW_MT: vp8e_enc_control_id = 54;
pub const vp8e_enc_control_id_VP9E_GET_LEVEL: vp8e_enc_control_id = 55;
pub const vp8e_enc_control_id_VP9E_SET_ALT_REF_AQ: vp8e_enc_control_id = 56;
pub const vp8e_enc_control_id_VP8E_SET_GF_CBR_BOOST_PCT: vp8e_enc_control_id = 57;
pub const vp8e_enc_control_id_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST: vp8e_enc_control_id = 58;
pub type vp8e_enc_control_id = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_scaling_mode_1d {
  VP8E_NORMAL = 0,
  VP8E_FOURFIVE = 1,
  VP8E_THREEFIVE = 2,
  VP8E_ONETWO = 3,
}
pub use self::vpx_scaling_mode_1d as VPX_SCALING_MODE;
pub const vp9e_temporal_layering_mode_VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING:
  vp9e_temporal_layering_mode = 0;
pub const vp9e_temporal_layering_mode_VP9E_TEMPORAL_LAYERING_MODE_BYPASS:
  vp9e_temporal_layering_mode = 1;
pub const vp9e_temporal_layering_mode_VP9E_TEMPORAL_LAYERING_MODE_0101:
  vp9e_temporal_layering_mode = 2;
pub const vp9e_temporal_layering_mode_VP9E_TEMPORAL_LAYERING_MODE_0212:
  vp9e_temporal_layering_mode = 3;
pub type vp9e_temporal_layering_mode = u32;
pub use self::vp9e_temporal_layering_mode as VP9E_TEMPORAL_LAYERING_MODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_roi_map {
  pub roi_map: *mut c_uchar,
  pub rows: c_uint,
  pub cols: c_uint,
  pub delta_q: [c_int; 4usize],
  pub delta_lf: [c_int; 4usize],
  pub static_threshold: [c_uint; 4usize],
}
pub type vpx_roi_map_t = vpx_roi_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_active_map {
  pub active_map: *mut c_uchar,
  pub rows: c_uint,
  pub cols: c_uint,
}
pub type vpx_active_map_t = vpx_active_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_scaling_mode {
  pub h_scaling_mode: VPX_SCALING_MODE,
  pub v_scaling_mode: VPX_SCALING_MODE,
}
pub type vpx_scaling_mode_t = vpx_scaling_mode;
pub const vp8e_token_partitions_VP8_ONE_TOKENPARTITION: vp8e_token_partitions = 0;
pub const vp8e_token_partitions_VP8_TWO_TOKENPARTITION: vp8e_token_partitions = 1;
pub const vp8e_token_partitions_VP8_FOUR_TOKENPARTITION: vp8e_token_partitions = 2;
pub const vp8e_token_partitions_VP8_EIGHT_TOKENPARTITION: vp8e_token_partitions = 3;
pub type vp8e_token_partitions = u32;
pub const vp9e_tune_content_VP9E_CONTENT_DEFAULT: vp9e_tune_content = 0;
pub const vp9e_tune_content_VP9E_CONTENT_SCREEN: vp9e_tune_content = 1;
pub const vp9e_tune_content_VP9E_CONTENT_FILM: vp9e_tune_content = 2;
pub const vp9e_tune_content_VP9E_CONTENT_INVALID: vp9e_tune_content = 3;
pub type vp9e_tune_content = u32;
pub const vp8e_tuning_VP8_TUNE_PSNR: vp8e_tuning = 0;
pub const vp8e_tuning_VP8_TUNE_SSIM: vp8e_tuning = 1;
pub type vp8e_tuning = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_svc_layer_id {
  pub spatial_layer_id: c_int,
  pub temporal_layer_id: c_int,
}
pub type vpx_svc_layer_id_t = vpx_svc_layer_id;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_svc_ref_frame_config {
  pub frame_flags: [c_int; 5usize],
  pub lst_fb_idx: [c_int; 5usize],
  pub gld_fb_idx: [c_int; 5usize],
  pub alt_fb_idx: [c_int; 5usize],
}
pub type vpx_svc_ref_frame_config_t = vpx_svc_ref_frame_config;
extern "C" {
  pub static mut vpx_codec_vp8_dx_algo: vpx_codec_iface_t;
  pub fn vpx_codec_vp8_dx() -> *mut vpx_codec_iface_t;
  pub static mut vpx_codec_vp9_dx_algo: vpx_codec_iface_t;
  pub fn vpx_codec_vp9_dx() -> *mut vpx_codec_iface_t;
}
pub const vp8_dec_control_id_VP8D_GET_LAST_REF_UPDATES: vp8_dec_control_id = 256;
pub const vp8_dec_control_id_VP8D_GET_FRAME_CORRUPTED: vp8_dec_control_id = 257;
pub const vp8_dec_control_id_VP8D_GET_LAST_REF_USED: vp8_dec_control_id = 258;
pub const vp8_dec_control_id_VPXD_SET_DECRYPTOR: vp8_dec_control_id = 259;
pub const vp8_dec_control_id_VP8D_SET_DECRYPTOR: vp8_dec_control_id = 259;
pub const vp8_dec_control_id_VP9D_GET_FRAME_SIZE: vp8_dec_control_id = 260;
pub const vp8_dec_control_id_VP9D_GET_DISPLAY_SIZE: vp8_dec_control_id = 261;
pub const vp8_dec_control_id_VP9D_GET_BIT_DEPTH: vp8_dec_control_id = 262;
pub const vp8_dec_control_id_VP9_SET_BYTE_ALIGNMENT: vp8_dec_control_id = 263;
pub const vp8_dec_control_id_VP9_INVERT_TILE_DECODE_ORDER: vp8_dec_control_id = 264;
pub const vp8_dec_control_id_VP9_SET_SKIP_LOOP_FILTER: vp8_dec_control_id = 265;
pub const vp8_dec_control_id_VP9_DECODE_SVC_SPATIAL_LAYER: vp8_dec_control_id = 266;
pub const vp8_dec_control_id_VPXD_GET_LAST_QUANTIZER: vp8_dec_control_id = 267;
pub const vp8_dec_control_id_VP8_DECODER_CTRL_ID_MAX: vp8_dec_control_id = 268;
pub type vp8_dec_control_id = u32;
pub type vpx_decrypt_cb = ::std::option::Option<
  unsafe extern "C" fn(
    decrypt_state: *mut c_void,
    input: *const c_uchar,
    output: *mut c_uchar,
    count: c_int,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_decrypt_init {
  pub decrypt_cb: vpx_decrypt_cb,
  pub decrypt_state: *mut c_void,
}
pub type vp8_decrypt_init = vpx_decrypt_init;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_frame_buffer {
  pub data: *mut u8,
  pub size: usize,
  pub priv_: *mut c_void,
}
pub type vpx_codec_frame_buffer_t = vpx_codec_frame_buffer;
pub type vpx_get_frame_buffer_cb_fn_t = ::std::option::Option<
  unsafe extern "C" fn(priv_: *mut c_void, min_size: usize, fb: *mut vpx_codec_frame_buffer_t)
    -> c_int,
>;
pub type vpx_release_frame_buffer_cb_fn_t = ::std::option::Option<
  unsafe extern "C" fn(priv_: *mut c_void, fb: *mut vpx_codec_frame_buffer_t) -> c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_stream_info {
  pub sz: c_uint,
  pub w: c_uint,
  pub h: c_uint,
  pub is_kf: c_uint,
}
pub type vpx_codec_stream_info_t = vpx_codec_stream_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_dec_cfg {
  pub threads: c_uint,
  pub w: c_uint,
  pub h: c_uint,
}
pub type vpx_codec_dec_cfg_t = vpx_codec_dec_cfg;
extern "C" {
  pub fn vpx_codec_dec_init_ver(
    ctx: *mut vpx_codec_ctx_t,
    iface: *mut vpx_codec_iface_t,
    cfg: *const vpx_codec_dec_cfg_t,
    flags: vpx_codec_flags_t,
    ver: c_int,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_peek_stream_info(
    iface: *mut vpx_codec_iface_t,
    data: *const u8,
    data_sz: c_uint,
    si: *mut vpx_codec_stream_info_t,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_get_stream_info(
    ctx: *mut vpx_codec_ctx_t,
    si: *mut vpx_codec_stream_info_t,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_decode(
    ctx: *mut vpx_codec_ctx_t,
    data: *const u8,
    data_sz: c_uint,
    user_priv: *mut c_void,
    deadline: c_long,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_get_frame(
    ctx: *mut vpx_codec_ctx_t,
    iter: *mut vpx_codec_iter_t,
  ) -> *mut vpx_image_t;
}
pub type vpx_codec_put_frame_cb_fn_t =
  ::std::option::Option<unsafe extern "C" fn(user_priv: *mut c_void, img: *const vpx_image_t)>;
extern "C" {
  pub fn vpx_codec_register_put_frame_cb(
    ctx: *mut vpx_codec_ctx_t,
    cb: vpx_codec_put_frame_cb_fn_t,
    user_priv: *mut c_void,
  ) -> vpx_codec_err_t;
}
pub type vpx_codec_put_slice_cb_fn_t = ::std::option::Option<
  unsafe extern "C" fn(
    user_priv: *mut c_void,
    img: *const vpx_image_t,
    valid: *const vpx_image_rect_t,
    update: *const vpx_image_rect_t,
  ),
>;
extern "C" {
  pub fn vpx_codec_register_put_slice_cb(
    ctx: *mut vpx_codec_ctx_t,
    cb: vpx_codec_put_slice_cb_fn_t,
    user_priv: *mut c_void,
  ) -> vpx_codec_err_t;
  pub fn vpx_codec_set_frame_buffer_functions(
    ctx: *mut vpx_codec_ctx_t,
    cb_get: vpx_get_frame_buffer_cb_fn_t,
    cb_release: vpx_release_frame_buffer_cb_fn_t,
    cb_priv: *mut c_void,
  ) -> vpx_codec_err_t;
}
