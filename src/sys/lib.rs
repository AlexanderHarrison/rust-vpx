#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(missing_copy_implementations)]
#![allow(non_upper_case_globals)]
extern crate libc;
/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const OBJC_NEW_PROPERTIES: ::std::os::raw::c_uint = 1;
pub const _LP64: ::std::os::raw::c_uint = 1;
pub const __APPLE_CC__: ::std::os::raw::c_uint = 6000;
pub const __APPLE__: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_ACQUIRE: ::std::os::raw::c_uint = 2;
pub const __ATOMIC_ACQ_REL: ::std::os::raw::c_uint = 4;
pub const __ATOMIC_CONSUME: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_RELAXED: ::std::os::raw::c_uint = 0;
pub const __ATOMIC_RELEASE: ::std::os::raw::c_uint = 3;
pub const __ATOMIC_SEQ_CST: ::std::os::raw::c_uint = 5;
pub const __BIGGEST_ALIGNMENT__: ::std::os::raw::c_uint = 16;
pub const __BLOCKS__: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT__: ::std::os::raw::c_uint = 8;
pub const __CONSTANT_CFSTRINGS__: ::std::os::raw::c_uint = 1;
pub const __DBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 17;
pub const __DBL_DIG__: ::std::os::raw::c_uint = 15;
pub const __DBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __DBL_MANT_DIG__: ::std::os::raw::c_uint = 53;
pub const __DBL_MAX_10_EXP__: ::std::os::raw::c_uint = 308;
pub const __DBL_MAX_EXP__: ::std::os::raw::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: ::std::os::raw::c_int = -307;
pub const __DBL_MIN_EXP__: ::std::os::raw::c_int = -1021;
pub const __DYNAMIC__: ::std::os::raw::c_uint = 1;
pub const __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__:
          ::std::os::raw::c_uint =
    101200;
pub const __FINITE_MATH_ONLY__: ::std::os::raw::c_uint = 0;
pub const __FLT_DECIMAL_DIG__: ::std::os::raw::c_uint = 9;
pub const __FLT_DIG__: ::std::os::raw::c_uint = 6;
pub const __FLT_EVAL_METHOD__: ::std::os::raw::c_uint = 0;
pub const __FLT_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __FLT_MANT_DIG__: ::std::os::raw::c_uint = 24;
pub const __FLT_MAX_10_EXP__: ::std::os::raw::c_uint = 38;
pub const __FLT_MAX_EXP__: ::std::os::raw::c_uint = 128;
pub const __FLT_MIN_10_EXP__: ::std::os::raw::c_int = -37;
pub const __FLT_MIN_EXP__: ::std::os::raw::c_int = -125;
pub const __FLT_RADIX__: ::std::os::raw::c_uint = 2;
pub const __FXSR__: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: ::std::os::raw::c_uint = 1;
pub const __GNUC_MINOR__: ::std::os::raw::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: ::std::os::raw::c_uint = 1;
pub const __GNUC_STDC_INLINE__: ::std::os::raw::c_uint = 1;
pub const __GNUC__: ::std::os::raw::c_uint = 4;
pub const __GXX_ABI_VERSION: ::std::os::raw::c_uint = 1002;
pub const __GXX_RTTI: ::std::os::raw::c_uint = 1;
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT64_FMTd__: &'static [u8; 4usize] = b"lld\x00";
pub const __INT64_FMTi__: &'static [u8; 4usize] = b"lli\x00";
pub const __INT64_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTMAX_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT_FAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT_FAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INT_FAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT_FAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT_LEAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT_LEAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INT_LEAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT_LEAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __LDBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __LDBL_DIG__: ::std::os::raw::c_uint = 18;
pub const __LDBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __LDBL_MANT_DIG__: ::std::os::raw::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: ::std::os::raw::c_uint = 4932;
pub const __LDBL_MAX_EXP__: ::std::os::raw::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: ::std::os::raw::c_int = -4931;
pub const __LDBL_MIN_EXP__: ::std::os::raw::c_int = -16381;
pub const __LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1;
pub const __LONG_LONG_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __LONG_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LP64__: ::std::os::raw::c_uint = 1;
pub const __MACH__: ::std::os::raw::c_uint = 1;
pub const __MMX__: ::std::os::raw::c_uint = 1;
pub const __NO_INLINE__: ::std::os::raw::c_uint = 1;
pub const __NO_MATH_INLINES: ::std::os::raw::c_uint = 1;
pub const __ORDER_BIG_ENDIAN__: ::std::os::raw::c_uint = 4321;
pub const __ORDER_LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1234;
pub const __ORDER_PDP_ENDIAN__: ::std::os::raw::c_uint = 3412;
pub const __PIC__: ::std::os::raw::c_uint = 2;
pub const __POINTER_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __PRAGMA_REDEFINE_EXTNAME: ::std::os::raw::c_uint = 1;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __PTRDIFF_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SCHAR_MAX__: ::std::os::raw::c_uint = 127;
pub const __SHRT_MAX__: ::std::os::raw::c_uint = 32767;
pub const __SIG_ATOMIC_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __SIG_ATOMIC_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_DOUBLE__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_FLOAT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT128__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_INT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_LONG_DOUBLE__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_POINTER__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTRDIFF_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SHORT__: ::std::os::raw::c_uint = 2;
pub const __SIZEOF_SIZE_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_WINT_T__: ::std::os::raw::c_uint = 4;
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_MAX__: ::std::os::raw::c_int = -1;
pub const __SIZE_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SSE2_MATH__: ::std::os::raw::c_uint = 1;
pub const __SSE2__: ::std::os::raw::c_uint = 1;
pub const __SSE3__: ::std::os::raw::c_uint = 1;
pub const __SSE4_1__: ::std::os::raw::c_uint = 1;
pub const __SSE_MATH__: ::std::os::raw::c_uint = 1;
pub const __SSE__: ::std::os::raw::c_uint = 1;
pub const __SSP__: ::std::os::raw::c_uint = 1;
pub const __SSSE3__: ::std::os::raw::c_uint = 1;
pub const __STDC_HOSTED__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_16__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_32__: ::std::os::raw::c_uint = 1;
pub const __STDC_VERSION__: ::std::os::raw::c_uint = 201112;
pub const __STDC__: ::std::os::raw::c_uint = 1;
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT64_FMTX__: &'static [u8; 4usize] = b"llX\x00";
pub const __UINT64_FMTo__: &'static [u8; 4usize] = b"llo\x00";
pub const __UINT64_FMTu__: &'static [u8; 4usize] = b"llu\x00";
pub const __UINT64_FMTx__: &'static [u8; 4usize] = b"llx\x00";
pub const __UINT64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)\x00";
pub const __WCHAR_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __WCHAR_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __WINT_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __amd64: ::std::os::raw::c_uint = 1;
pub const __amd64__: ::std::os::raw::c_uint = 1;
pub const __apple_build_version__: ::std::os::raw::c_uint = 8000038;
pub const __clang__: ::std::os::raw::c_uint = 1;
pub const __clang_major__: ::std::os::raw::c_uint = 8;
pub const __clang_minor__: ::std::os::raw::c_uint = 0;
pub const __clang_patchlevel__: ::std::os::raw::c_uint = 0;
pub const __clang_version__: &'static [u8; 23usize] =
    b"8.0.0 (clang-800.0.38)\x00";
pub const __core2: ::std::os::raw::c_uint = 1;
pub const __core2__: ::std::os::raw::c_uint = 1;
pub const __llvm__: ::std::os::raw::c_uint = 1;
pub const __pic__: ::std::os::raw::c_uint = 2;
pub const __tune_core2__: ::std::os::raw::c_uint = 1;
pub const __x86_64: ::std::os::raw::c_uint = 1;
pub const __x86_64__: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\x00";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const PRId8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIo8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRId16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIi16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIo16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIu16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIx16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIX16: &'static [u8; 3usize] = b"hX\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRId64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIi64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIo64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIu64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIx64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIX64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNd64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNi64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNo64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNu64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNx64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __MAC_OS_X_VERSION_MIN_REQUIRED: ::std::os::raw::c_uint = 101200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101200;
pub const __DARWIN_WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const VPX_IMAGE_ABI_VERSION: ::std::os::raw::c_uint = 4;
pub const VPX_IMG_FMT_PLANAR: ::std::os::raw::c_uint = 256;
pub const VPX_IMG_FMT_UV_FLIP: ::std::os::raw::c_uint = 512;
pub const VPX_IMG_FMT_HAS_ALPHA: ::std::os::raw::c_uint = 1024;
pub const VPX_IMG_FMT_HIGHBITDEPTH: ::std::os::raw::c_uint = 2048;
pub const VPX_PLANE_PACKED: ::std::os::raw::c_uint = 0;
pub const VPX_PLANE_Y: ::std::os::raw::c_uint = 0;
pub const VPX_PLANE_U: ::std::os::raw::c_uint = 1;
pub const VPX_PLANE_V: ::std::os::raw::c_uint = 2;
pub const VPX_PLANE_ALPHA: ::std::os::raw::c_uint = 3;
pub const VPX_CODEC_ABI_VERSION: ::std::os::raw::c_uint = 7;
pub const VPX_CODEC_CAP_DECODER: ::std::os::raw::c_uint = 1;
pub const VPX_CODEC_CAP_ENCODER: ::std::os::raw::c_uint = 2;
pub const VPX_TS_MAX_PERIODICITY: ::std::os::raw::c_uint = 16;
pub const VPX_TS_MAX_LAYERS: ::std::os::raw::c_uint = 5;
pub const MAX_PERIODICITY: ::std::os::raw::c_uint = 16;
pub const VPX_MAX_LAYERS: ::std::os::raw::c_uint = 12;
pub const MAX_LAYERS: ::std::os::raw::c_uint = 12;
pub const VPX_SS_MAX_LAYERS: ::std::os::raw::c_uint = 5;
pub const VPX_SS_DEFAULT_LAYERS: ::std::os::raw::c_uint = 1;
pub const VPX_ENCODER_ABI_VERSION: ::std::os::raw::c_uint = 12;
pub const VPX_CODEC_CAP_PSNR: ::std::os::raw::c_uint = 65536;
pub const VPX_CODEC_CAP_OUTPUT_PARTITION: ::std::os::raw::c_uint = 131072;
pub const VPX_CODEC_CAP_HIGHBITDEPTH: ::std::os::raw::c_uint = 262144;
pub const VPX_CODEC_USE_PSNR: ::std::os::raw::c_uint = 65536;
pub const VPX_CODEC_USE_OUTPUT_PARTITION: ::std::os::raw::c_uint = 131072;
pub const VPX_CODEC_USE_HIGHBITDEPTH: ::std::os::raw::c_uint = 262144;
pub const VPX_FRAME_IS_KEY: ::std::os::raw::c_uint = 1;
pub const VPX_FRAME_IS_DROPPABLE: ::std::os::raw::c_uint = 2;
pub const VPX_FRAME_IS_INVISIBLE: ::std::os::raw::c_uint = 4;
pub const VPX_FRAME_IS_FRAGMENT: ::std::os::raw::c_uint = 8;
pub const VPX_ERROR_RESILIENT_DEFAULT: ::std::os::raw::c_uint = 1;
pub const VPX_ERROR_RESILIENT_PARTITIONS: ::std::os::raw::c_uint = 2;
pub const VPX_EFLAG_FORCE_KF: ::std::os::raw::c_uint = 1;
pub const VPX_DL_REALTIME: ::std::os::raw::c_uint = 1;
pub const VPX_DL_GOOD_QUALITY: ::std::os::raw::c_uint = 1000000;
pub const VPX_DL_BEST_QUALITY: ::std::os::raw::c_uint = 0;
pub const VP8_EFLAG_NO_REF_LAST: ::std::os::raw::c_uint = 65536;
pub const VP8_EFLAG_NO_REF_GF: ::std::os::raw::c_uint = 131072;
pub const VP8_EFLAG_NO_REF_ARF: ::std::os::raw::c_uint = 2097152;
pub const VP8_EFLAG_NO_UPD_LAST: ::std::os::raw::c_uint = 262144;
pub const VP8_EFLAG_NO_UPD_GF: ::std::os::raw::c_uint = 4194304;
pub const VP8_EFLAG_NO_UPD_ARF: ::std::os::raw::c_uint = 8388608;
pub const VP8_EFLAG_FORCE_GF: ::std::os::raw::c_uint = 524288;
pub const VP8_EFLAG_FORCE_ARF: ::std::os::raw::c_uint = 16777216;
pub const VP8_EFLAG_NO_UPD_ENTROPY: ::std::os::raw::c_uint = 1048576;
pub const VPX_MAXIMUM_WORK_BUFFERS: ::std::os::raw::c_uint = 8;
pub const VP9_MAXIMUM_REF_BUFFERS: ::std::os::raw::c_uint = 8;
pub const VPX_DECODER_ABI_VERSION: ::std::os::raw::c_uint = 10;
pub const VPX_CODEC_CAP_PUT_SLICE: ::std::os::raw::c_uint = 65536;
pub const VPX_CODEC_CAP_PUT_FRAME: ::std::os::raw::c_uint = 131072;
pub const VPX_CODEC_CAP_POSTPROC: ::std::os::raw::c_uint = 262144;
pub const VPX_CODEC_CAP_ERROR_CONCEALMENT: ::std::os::raw::c_uint = 524288;
pub const VPX_CODEC_CAP_INPUT_FRAGMENTS: ::std::os::raw::c_uint = 1048576;
pub const VPX_CODEC_CAP_FRAME_THREADING: ::std::os::raw::c_uint = 2097152;
pub const VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER: ::std::os::raw::c_uint =
    4194304;
pub const VPX_CODEC_USE_POSTPROC: ::std::os::raw::c_uint = 65536;
pub const VPX_CODEC_USE_ERROR_CONCEALMENT: ::std::os::raw::c_uint = 131072;
pub const VPX_CODEC_USE_INPUT_FRAGMENTS: ::std::os::raw::c_uint = 262144;
pub const VPX_CODEC_USE_FRAME_THREADING: ::std::os::raw::c_uint = 524288;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 8usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type __mbstate_t = _bindgen_ty_1;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
               8usize);
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize);
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize);
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutexattr_t>() ,
               8usize);
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize);
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
               8usize);
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_t>() , 8usize);
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 8usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type imaxdiv_t = _bindgen_ty_2;
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
#[repr(u32)]
/* \brief List of supported image formats */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_img_fmt {
    VPX_IMG_FMT_NONE = 0,
    VPX_IMG_FMT_RGB24 = 1,
    VPX_IMG_FMT_RGB32 = 2,
    VPX_IMG_FMT_RGB565 = 3,
    VPX_IMG_FMT_RGB555 = 4,
    VPX_IMG_FMT_UYVY = 5,
    VPX_IMG_FMT_YUY2 = 6,
    VPX_IMG_FMT_YVYU = 7,
    VPX_IMG_FMT_BGR24 = 8,
    VPX_IMG_FMT_RGB32_LE = 9,
    VPX_IMG_FMT_ARGB = 10,
    VPX_IMG_FMT_ARGB_LE = 11,
    VPX_IMG_FMT_RGB565_LE = 12,
    VPX_IMG_FMT_RGB555_LE = 13,
    VPX_IMG_FMT_YV12 = 769,
    VPX_IMG_FMT_I420 = 258,
    VPX_IMG_FMT_VPXYV12 = 771,
    VPX_IMG_FMT_VPXI420 = 260,
    VPX_IMG_FMT_I422 = 261,
    VPX_IMG_FMT_I444 = 262,
    VPX_IMG_FMT_I440 = 263,
    VPX_IMG_FMT_444A = 1286,
    VPX_IMG_FMT_I42016 = 2306,
    VPX_IMG_FMT_I42216 = 2309,
    VPX_IMG_FMT_I44416 = 2310,
    VPX_IMG_FMT_I44016 = 2311,
}
pub use self::vpx_img_fmt as vpx_img_fmt_t;
#[repr(u32)]
/* \brief List of supported color spaces */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_color_space {
    VPX_CS_UNKNOWN = 0,
    VPX_CS_BT_601 = 1,
    VPX_CS_BT_709 = 2,
    VPX_CS_SMPTE_170 = 3,
    VPX_CS_SMPTE_240 = 4,
    VPX_CS_BT_2020 = 5,
    VPX_CS_RESERVED = 6,
    VPX_CS_SRGB = 7,
}
pub use self::vpx_color_space as vpx_color_space_t;
#[repr(u32)]
/* \brief List of supported color range */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_color_range { VPX_CR_STUDIO_RANGE = 0, VPX_CR_FULL_RANGE = 1, }
pub use self::vpx_color_range as vpx_color_range_t;
/**\brief Image Descriptor */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_image {
    /**< Image Format */
    pub fmt: vpx_img_fmt_t,
    /**< Color Space */
    pub cs: vpx_color_space_t,
    /**< Color Range */
    pub range: vpx_color_range_t,
    /**< Stored image width */
    pub w: ::std::os::raw::c_uint,
    /**< Stored image height */
    pub h: ::std::os::raw::c_uint,
    /**< Stored image bit-depth */
    pub bit_depth: ::std::os::raw::c_uint,
    /**< Displayed image width */
    pub d_w: ::std::os::raw::c_uint,
    /**< Displayed image height */
    pub d_h: ::std::os::raw::c_uint,
    /**< Intended rendering image width */
    pub r_w: ::std::os::raw::c_uint,
    /**< Intended rendering image height */
    pub r_h: ::std::os::raw::c_uint,
    /**< subsampling order, X */
    pub x_chroma_shift: ::std::os::raw::c_uint,
    /**< subsampling order, Y */
    pub y_chroma_shift: ::std::os::raw::c_uint,
    /**< pointer to the top left pixel for each plane */
    pub planes: [*mut ::std::os::raw::c_uchar; 4usize],
    /**< stride between rows for each plane */
    pub stride: [::std::os::raw::c_int; 4usize],
    /**< bits per sample (for packed formats) */
    pub bps: ::std::os::raw::c_int,
    /* \brief The following member may be set by the application to associate
   * data with this image.
   */
    pub user_priv: *mut ::std::os::raw::c_void,
    /**< private */
    pub img_data: *mut ::std::os::raw::c_uchar,
    /**< private */
    pub img_data_owner: ::std::os::raw::c_int,
    /**< private */
    pub self_allocd: ::std::os::raw::c_int,
    /**< Frame buffer data associated with the image. */
    pub fb_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_image() {
    assert_eq!(::std::mem::size_of::<vpx_image>() , 136usize);
    assert_eq!(::std::mem::align_of::<vpx_image>() , 8usize);
}
impl Clone for vpx_image {
    fn clone(&self) -> Self { *self }
}
pub type vpx_image_t = vpx_image;
/**\brief Representation of a rectangle on a surface */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_image_rect {
    /**< leftmost column */
    pub x: ::std::os::raw::c_uint,
    /**< topmost row */
    pub y: ::std::os::raw::c_uint,
    /**< width */
    pub w: ::std::os::raw::c_uint,
    /**< height */
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_image_rect() {
    assert_eq!(::std::mem::size_of::<vpx_image_rect>() , 16usize);
    assert_eq!(::std::mem::align_of::<vpx_image_rect>() , 4usize);
}
impl Clone for vpx_image_rect {
    fn clone(&self) -> Self { *self }
}
pub type vpx_image_rect_t = vpx_image_rect;
extern "C" {
    /* \brief Open a descriptor, allocating storage for the underlying image
 *
 * Returns a descriptor for storing an image of the given format. The
 * storage for the descriptor is allocated on the heap.
 *
 * \param[in]    img       Pointer to storage for descriptor. If this parameter
 *                         is NULL, the storage for the descriptor will be
 *                         allocated on the heap.
 * \param[in]    fmt       Format for the image
 * \param[in]    d_w       Width of the image
 * \param[in]    d_h       Height of the image
 * \param[in]    align     Alignment, in bytes, of the image buffer and
 *                         each row in the image(stride).
 *
 * \return Returns a pointer to the initialized image descriptor. If the img
 *         parameter is non-null, the value of the img parameter will be
 *         returned.
 */
    pub fn vpx_img_alloc(img: *mut vpx_image_t, fmt: vpx_img_fmt_t,
                         d_w: ::std::os::raw::c_uint,
                         d_h: ::std::os::raw::c_uint,
                         align: ::std::os::raw::c_uint) -> *mut vpx_image_t;
}
extern "C" {
    /* \brief Open a descriptor, using existing storage for the underlying image
 *
 * Returns a descriptor for storing an image of the given format. The
 * storage for descriptor has been allocated elsewhere, and a descriptor is
 * desired to "wrap" that storage.
 *
 * \param[in]    img       Pointer to storage for descriptor. If this parameter
 *                         is NULL, the storage for the descriptor will be
 *                         allocated on the heap.
 * \param[in]    fmt       Format for the image
 * \param[in]    d_w       Width of the image
 * \param[in]    d_h       Height of the image
 * \param[in]    align     Alignment, in bytes, of each row in the image.
 * \param[in]    img_data  Storage to use for the image
 *
 * \return Returns a pointer to the initialized image descriptor. If the img
 *         parameter is non-null, the value of the img parameter will be
 *         returned.
 */
    pub fn vpx_img_wrap(img: *mut vpx_image_t, fmt: vpx_img_fmt_t,
                        d_w: ::std::os::raw::c_uint,
                        d_h: ::std::os::raw::c_uint,
                        align: ::std::os::raw::c_uint,
                        img_data: *mut ::std::os::raw::c_uchar)
     -> *mut vpx_image_t;
}
extern "C" {
    /* \brief Set the rectangle identifying the displayed portion of the image
 *
 * Updates the displayed rectangle (aka viewport) on the image surface to
 * match the specified coordinates and size.
 *
 * \param[in]    img       Image descriptor
 * \param[in]    x         leftmost column
 * \param[in]    y         topmost row
 * \param[in]    w         width
 * \param[in]    h         height
 *
 * \return 0 if the requested rectangle is valid, nonzero otherwise.
 */
    pub fn vpx_img_set_rect(img: *mut vpx_image_t, x: ::std::os::raw::c_uint,
                            y: ::std::os::raw::c_uint,
                            w: ::std::os::raw::c_uint,
                            h: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /* \brief Flip the image vertically (top for bottom)
 *
 * Adjusts the image descriptor's pointers and strides to make the image
 * be referenced upside-down.
 *
 * \param[in]    img       Image descriptor
 */
    pub fn vpx_img_flip(img: *mut vpx_image_t);
}
extern "C" {
    /* \brief Close an image descriptor
 *
 * Frees all allocated storage associated with an image descriptor.
 *
 * \param[in]    img       Image descriptor
 */
    pub fn vpx_img_free(img: *mut vpx_image_t);
}
pub const VPX_CODEC_OK: _bindgen_ty_3 = _bindgen_ty_3::VPX_CODEC_OK;
pub const VPX_CODEC_ERROR: _bindgen_ty_3 = _bindgen_ty_3::VPX_CODEC_ERROR;
pub const VPX_CODEC_MEM_ERROR: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_MEM_ERROR;
pub const VPX_CODEC_ABI_MISMATCH: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_ABI_MISMATCH;
pub const VPX_CODEC_INCAPABLE: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_INCAPABLE;
pub const VPX_CODEC_UNSUP_BITSTREAM: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_UNSUP_BITSTREAM;
pub const VPX_CODEC_UNSUP_FEATURE: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_UNSUP_FEATURE;
pub const VPX_CODEC_CORRUPT_FRAME: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_CORRUPT_FRAME;
pub const VPX_CODEC_INVALID_PARAM: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_INVALID_PARAM;
pub const VPX_CODEC_LIST_END: _bindgen_ty_3 =
    _bindgen_ty_3::VPX_CODEC_LIST_END;
#[repr(u32)]
/* \brief Algorithm return codes */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    VPX_CODEC_OK = 0,
    VPX_CODEC_ERROR = 1,
    VPX_CODEC_MEM_ERROR = 2,
    VPX_CODEC_ABI_MISMATCH = 3,
    VPX_CODEC_INCAPABLE = 4,
    VPX_CODEC_UNSUP_BITSTREAM = 5,
    VPX_CODEC_UNSUP_FEATURE = 6,
    VPX_CODEC_CORRUPT_FRAME = 7,
    VPX_CODEC_INVALID_PARAM = 8,
    VPX_CODEC_LIST_END = 9,
}
pub use self::_bindgen_ty_3 as vpx_codec_err_t;
/*  \brief Codec capabilities bitfield
 *
 *  Each codec advertises the capabilities it supports as part of its
 *  ::vpx_codec_iface_t interface structure. Capabilities are extra interfaces
 *  or functionality, and are not required to be supported.
 *
 *  The available flags are specified by VPX_CODEC_CAP_* defines.
 */
pub type vpx_codec_caps_t = ::std::os::raw::c_long;
/*  \brief Initialization-time Feature Enabling
 *
 *  Certain codec features must be known at initialization time, to allow for
 *  proper memory allocation.
 *
 *  The available flags are specified by VPX_CODEC_USE_* defines.
 */
pub type vpx_codec_flags_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_iface([u8; 0]);
/* \brief Codec interface structure.
 *
 * Contains function pointers and other data private to the codec
 * implementation. This structure is opaque to the application.
 */
pub type vpx_codec_iface_t = vpx_codec_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_priv([u8; 0]);
/* \brief Codec private data structure.
 *
 * Contains data private to the codec implementation. This structure is opaque
 * to the application.
 */
pub type vpx_codec_priv_t = vpx_codec_priv;
/* \brief Iterator
 *
 * Opaque storage used for iterating over lists.
 */
pub type vpx_codec_iter_t = *const ::std::os::raw::c_void;
/* \brief Codec context structure
 *
 * All codecs \ref MUST support this context structure fully. In general,
 * this data should be considered private to the codec algorithm, and
 * not be manipulated or examined by the calling application. Applications
 * may reference the 'name' member to get a printable description of the
 * algorithm.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_ctx {
    /**< Printable interface name */
    pub name: *const ::std::os::raw::c_char,
    /**< Interface pointers */
    pub iface: *mut vpx_codec_iface_t,
    /**< Last returned error */
    pub err: vpx_codec_err_t,
    /**< Detailed info, if available */
    pub err_detail: *const ::std::os::raw::c_char,
    /**< Flags passed at init time */
    pub init_flags: vpx_codec_flags_t,
    /**< Configuration pointer aliasing union */
    pub config: vpx_codec_ctx__bindgen_ty_1,
    /**< Algorithm private storage */
    pub priv_: *mut vpx_codec_priv_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_ctx__bindgen_ty_1 {
    pub dec: __BindgenUnionField<*const vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg>,
    pub enc: __BindgenUnionField<*const vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg>,
    pub raw: __BindgenUnionField<*const ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
/* \brief Initialization Configurations
 *
 * This structure is used to pass init time configuration options to the
 * decoder.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg {
    /**< Maximum number of threads to use, default 1 */
    pub threads: ::std::os::raw::c_uint,
    /**< Width */
    pub w: ::std::os::raw::c_uint,
    /**< Height */
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg() {
    assert_eq!(::std::mem::size_of::<vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg>()
               , 4usize);
}
impl Clone for vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg {
    fn clone(&self) -> Self { *self }
}
/* \brief Encoder configuration structure
 *
 * This structure contains the encoder settings that have common representations
 * across all codecs. This doesn't imply that all codecs support all features,
 * however.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg {
    /* \brief Algorithm specific "usage" value
   *
   * Algorithms may define multiple values for usage, which may convey the
   * intent of how the application intends to use the stream. If this value
   * is non-zero, consult the documentation for the codec to determine its
   * meaning.
   */
    pub g_usage: ::std::os::raw::c_uint,
    /* \brief Maximum number of threads to use
   *
   * For multi-threaded implementations, use no more than this number of
   * threads. The codec may use fewer threads than allowed. The value
   * 0 is equivalent to the value 1.
   */
    pub g_threads: ::std::os::raw::c_uint,
    /**< profile of bitstream to use */
    pub g_profile: ::std::os::raw::c_uint,
    /* \brief Width of the frame
   *
   * This value identifies the presentation resolution of the frame,
   * in pixels. Note that the frames passed as input to the encoder must
   * have this resolution. Frames will be presented by the decoder in this
   * resolution, independent of any spatial resampling the encoder may do.
   */
    pub g_w: ::std::os::raw::c_uint,
    /* \brief Height of the frame
   *
   * This value identifies the presentation resolution of the frame,
   * in pixels. Note that the frames passed as input to the encoder must
   * have this resolution. Frames will be presented by the decoder in this
   * resolution, independent of any spatial resampling the encoder may do.
   */
    pub g_h: ::std::os::raw::c_uint,
    /* \brief Bit-depth of the codec
   *
   * This value identifies the bit_depth of the codec,
   * Only certain bit-depths are supported as identified in the
   * vpx_bit_depth_t enum.
   */
    pub g_bit_depth: vpx_bit_depth_t,
    /* \brief Bit-depth of the input frames
   *
   * This value identifies the bit_depth of the input frames in bits.
   * Note that the frames passed as input to the encoder must have
   * this bit-depth.
   */
    pub g_input_bit_depth: ::std::os::raw::c_uint,
    /* \brief Stream timebase units
   *
   * Indicates the smallest interval of time, in seconds, used by the stream.
   * For fixed frame rate material, or variable frame rate material where
   * frames are timed at a multiple of a given clock (ex: video capture),
   * the \ref RECOMMENDED method is to set the timebase to the reciprocal
   * of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the
   * pts to correspond to the frame number, which can be handy. For
   * re-encoding video from containers with absolute time timestamps, the
   * \ref RECOMMENDED method is to set the timebase to that of the parent
   * container or multimedia framework (ex: 1/1000 for ms, as in FLV).
   */
    pub g_timebase: vpx_rational,
    /* \brief Enable error resilient modes.
   *
   * The error resilient bitfield indicates to the encoder which features
   * it should enable to take measures for streaming over lossy or noisy
   * links.
   */
    pub g_error_resilient: vpx_codec_er_flags_t,
    /* \brief Multi-pass Encoding Mode
   *
   * This value should be set to the current phase for multi-pass encoding.
   * For single pass, set to #VPX_RC_ONE_PASS.
   */
    pub g_pass: vpx_enc_pass,
    /* \brief Allow lagged encoding
   *
   * If set, this value allows the encoder to consume a number of input
   * frames before producing output frames. This allows the encoder to
   * base decisions for the current frame on future frames. This does
   * increase the latency of the encoding pipeline, so it is not appropriate
   * in all situations (ex: realtime encoding).
   *
   * Note that this is a maximum value -- the encoder may produce frames
   * sooner than the given limit. Set this value to 0 to disable this
   * feature.
   */
    pub g_lag_in_frames: ::std::os::raw::c_uint,
    /* \brief Temporal resampling configuration, if supported by the codec.
   *
   * Temporal resampling allows the codec to "drop" frames as a strategy to
   * meet its target data rate. This can cause temporal discontinuities in
   * the encoded video, which may appear as stuttering during playback. This
   * trade-off is often acceptable, but for many applications is not. It can
   * be disabled in these cases.
   *
   * Note that not all codecs support this feature. All vpx VPx codecs do.
   * For other codecs, consult the documentation for that algorithm.
   *
   * This threshold is described as a percentage of the target data buffer.
   * When the data buffer falls below this percentage of fullness, a
   * dropped frame is indicated. Set the threshold to zero (0) to disable
   * this feature.
   */
    pub rc_dropframe_thresh: ::std::os::raw::c_uint,
    /* \brief Enable/disable spatial resampling, if supported by the codec.
   *
   * Spatial resampling allows the codec to compress a lower resolution
   * version of the frame, which is then upscaled by the encoder to the
   * correct presentation resolution. This increases visual quality at
   * low data rates, at the expense of CPU time on the encoder/decoder.
   */
    pub rc_resize_allowed: ::std::os::raw::c_uint,
    /* \brief Internal coded frame width.
   *
   * If spatial resampling is enabled this specifies the width of the
   * encoded frame.
   */
    pub rc_scaled_width: ::std::os::raw::c_uint,
    /* \brief Internal coded frame height.
   *
   * If spatial resampling is enabled this specifies the height of the
   * encoded frame.
   */
    pub rc_scaled_height: ::std::os::raw::c_uint,
    /* \brief Spatial resampling up watermark.
   *
   * This threshold is described as a percentage of the target data buffer.
   * When the data buffer rises above this percentage of fullness, the
   * encoder will step up to a higher resolution version of the frame.
   */
    pub rc_resize_up_thresh: ::std::os::raw::c_uint,
    /* \brief Spatial resampling down watermark.
   *
   * This threshold is described as a percentage of the target data buffer.
   * When the data buffer falls below this percentage of fullness, the
   * encoder will step down to a lower resolution version of the frame.
   */
    pub rc_resize_down_thresh: ::std::os::raw::c_uint,
    /* \brief Rate control algorithm to use.
   *
   * Indicates whether the end usage of this stream is to be streamed over
   * a bandwidth constrained link, indicating that Constant Bit Rate (CBR)
   * mode should be used, or whether it will be played back on a high
   * bandwidth link, as from a local disk, where higher variations in
   * bitrate are acceptable.
   */
    pub rc_end_usage: vpx_rc_mode,
    /* \brief Two-pass stats buffer.
   *
   * A buffer containing all of the stats packets produced in the first
   * pass, concatenated.
   */
    pub rc_twopass_stats_in: vpx_fixed_buf_t,
    /* \brief first pass mb stats buffer.
   *
   * A buffer containing all of the first pass mb stats packets produced
   * in the first pass, concatenated.
   */
    pub rc_firstpass_mb_stats_in: vpx_fixed_buf_t,
    /* \brief Target data rate
   *
   * Target bandwidth to use for this stream, in kilobits per second.
   */
    pub rc_target_bitrate: ::std::os::raw::c_uint,
    /* \brief Minimum (Best Quality) Quantizer
   *
   * The quantizer is the most direct control over the quality of the
   * encoded image. The range of valid values for the quantizer is codec
   * specific. Consult the documentation for the codec to determine the
   * values to use. To determine the range programmatically, call
   * vpx_codec_enc_config_default() with a usage value of 0.
   */
    pub rc_min_quantizer: ::std::os::raw::c_uint,
    /* \brief Maximum (Worst Quality) Quantizer
   *
   * The quantizer is the most direct control over the quality of the
   * encoded image. The range of valid values for the quantizer is codec
   * specific. Consult the documentation for the codec to determine the
   * values to use. To determine the range programmatically, call
   * vpx_codec_enc_config_default() with a usage value of 0.
   */
    pub rc_max_quantizer: ::std::os::raw::c_uint,
    /* \brief Rate control adaptation undershoot control
   *
   * This value, expressed as a percentage of the target bitrate,
   * controls the maximum allowed adaptation speed of the codec.
   * This factor controls the maximum amount of bits that can
   * be subtracted from the target bitrate in order to compensate
   * for prior overshoot.
   *
   * Valid values in the range 0-1000.
   */
    pub rc_undershoot_pct: ::std::os::raw::c_uint,
    /* \brief Rate control adaptation overshoot control
   *
   * This value, expressed as a percentage of the target bitrate,
   * controls the maximum allowed adaptation speed of the codec.
   * This factor controls the maximum amount of bits that can
   * be added to the target bitrate in order to compensate for
   * prior undershoot.
   *
   * Valid values in the range 0-1000.
   */
    pub rc_overshoot_pct: ::std::os::raw::c_uint,
    /* \brief Decoder Buffer Size
   *
   * This value indicates the amount of data that may be buffered by the
   * decoding application. Note that this value is expressed in units of
   * time (milliseconds). For example, a value of 5000 indicates that the
   * client will buffer (at least) 5000ms worth of encoded data. Use the
   * target bitrate (#rc_target_bitrate) to convert to bits/bytes, if
   * necessary.
   */
    pub rc_buf_sz: ::std::os::raw::c_uint,
    /* \brief Decoder Buffer Initial Size
   *
   * This value indicates the amount of data that will be buffered by the
   * decoding application prior to beginning playback. This value is
   * expressed in units of time (milliseconds). Use the target bitrate
   * (#rc_target_bitrate) to convert to bits/bytes, if necessary.
   */
    pub rc_buf_initial_sz: ::std::os::raw::c_uint,
    /* \brief Decoder Buffer Optimal Size
   *
   * This value indicates the amount of data that the encoder should try
   * to maintain in the decoder's buffer. This value is expressed in units
   * of time (milliseconds). Use the target bitrate (#rc_target_bitrate)
   * to convert to bits/bytes, if necessary.
   */
    pub rc_buf_optimal_sz: ::std::os::raw::c_uint,
    /* \brief Two-pass mode CBR/VBR bias
   *
   * Bias, expressed on a scale of 0 to 100, for determining target size
   * for the current frame. The value 0 indicates the optimal CBR mode
   * value should be used. The value 100 indicates the optimal VBR mode
   * value should be used. Values in between indicate which way the
   * encoder should "lean."
   */
    pub rc_2pass_vbr_bias_pct: ::std::os::raw::c_uint,
    /* \brief Two-pass mode per-GOP minimum bitrate
   *
   * This value, expressed as a percentage of the target bitrate, indicates
   * the minimum bitrate to be used for a single GOP (aka "section")
   */
    pub rc_2pass_vbr_minsection_pct: ::std::os::raw::c_uint,
    /* \brief Two-pass mode per-GOP maximum bitrate
   *
   * This value, expressed as a percentage of the target bitrate, indicates
   * the maximum bitrate to be used for a single GOP (aka "section")
   */
    pub rc_2pass_vbr_maxsection_pct: ::std::os::raw::c_uint,
    /* \brief Keyframe placement mode
   *
   * This value indicates whether the encoder should place keyframes at a
   * fixed interval, or determine the optimal placement automatically
   * (as governed by the #kf_min_dist and #kf_max_dist parameters)
   */
    pub kf_mode: vpx_kf_mode,
    /* \brief Keyframe minimum interval
   *
   * This value, expressed as a number of frames, prevents the encoder from
   * placing a keyframe nearer than kf_min_dist to the previous keyframe. At
   * least kf_min_dist frames non-keyframes will be coded before the next
   * keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval.
   */
    pub kf_min_dist: ::std::os::raw::c_uint,
    /* \brief Keyframe maximum interval
   *
   * This value, expressed as a number of frames, forces the encoder to code
   * a keyframe if one has not been coded in the last kf_max_dist frames.
   * A value of 0 implies all frames will be keyframes. Set kf_min_dist
   * equal to kf_max_dist for a fixed interval.
   */
    pub kf_max_dist: ::std::os::raw::c_uint,
    /* \brief Number of spatial coding layers.
   *
   * This value specifies the number of spatial coding layers to be used.
   */
    pub ss_number_layers: ::std::os::raw::c_uint,
    /* \brief Enable auto alt reference flags for each spatial layer.
   *
   * These values specify if auto alt reference frame is enabled for each
   * spatial layer.
   */
    pub ss_enable_auto_alt_ref: [::std::os::raw::c_int; 5usize],
    /* \brief Target bitrate for each spatial layer.
   *
   * These values specify the target coding bitrate to be used for each
   * spatial layer.
   */
    pub ss_target_bitrate: [::std::os::raw::c_uint; 5usize],
    /* \brief Number of temporal coding layers.
   *
   * This value specifies the number of temporal layers to be used.
   */
    pub ts_number_layers: ::std::os::raw::c_uint,
    /* \brief Target bitrate for each temporal layer.
   *
   * These values specify the target coding bitrate to be used for each
   * temporal layer.
   */
    pub ts_target_bitrate: [::std::os::raw::c_uint; 5usize],
    /* \brief Frame rate decimation factor for each temporal layer.
   *
   * These values specify the frame rate decimation factors to apply
   * to each temporal layer.
   */
    pub ts_rate_decimator: [::std::os::raw::c_uint; 5usize],
    /* \brief Length of the sequence defining frame temporal layer membership.
   *
   * This value specifies the length of the sequence that defines the
   * membership of frames to temporal layers. For example, if the
   * ts_periodicity = 8, then the frames are assigned to coding layers with a
   * repeated sequence of length 8.
  */
    pub ts_periodicity: ::std::os::raw::c_uint,
    /* \brief Template defining the membership of frames to temporal layers.
   *
   * This array defines the membership of frames to temporal coding layers.
   * For a 2-layer encoding that assigns even numbered frames to one temporal
   * layer (0) and odd numbered frames to a second temporal layer (1) with
   * ts_periodicity=8, then ts_layer_id = (0,1,0,1,0,1,0,1).
  */
    pub ts_layer_id: [::std::os::raw::c_uint; 16usize],
    /* \brief Target bitrate for each spatial/temporal layer.
   *
   * These values specify the target coding bitrate to be used for each
   * spatial/temporal layer.
   *
   */
    pub layer_target_bitrate: [::std::os::raw::c_uint; 12usize],
    /* \brief Temporal layering mode indicating which temporal layering scheme to
   * use.
   *
   * The value (refer to VP9E_TEMPORAL_LAYERING_MODE) specifies the
   * temporal layering mode to use.
   *
   */
    pub temporal_layering_mode: ::std::os::raw::c_int,
}

impl Default for vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg {
    fn default() -> Self {
        unsafe {::std::mem::zeroed()}
    }
}
impl Default for vpx_codec_ctx {
    fn default() -> Self {
        unsafe {::std::mem::zeroed()}
    }
}
impl Default for vpx_image_t {
    fn default() -> Self {
        unsafe {::std::mem::zeroed()}
    }
}

#[test]
fn bindgen_test_layout_vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg() {
    assert_eq!(::std::mem::size_of::<vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg>()
               , 376usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg>()
               , 8usize);
}
impl Clone for vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_vpx_codec_ctx__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<vpx_codec_ctx__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_ctx__bindgen_ty_1>() ,
               8usize);
}
impl Clone for vpx_codec_ctx__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_vpx_codec_ctx() {
    assert_eq!(::std::mem::size_of::<vpx_codec_ctx>() , 56usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_ctx>() , 8usize);
}
impl Clone for vpx_codec_ctx {
    fn clone(&self) -> Self { *self }
}
pub type vpx_codec_ctx_t = vpx_codec_ctx;
#[repr(u32)]
/* \brief Bit depth for codec
 * *
 * This enumeration determines the bit depth of the codec.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_bit_depth { VPX_BITS_8 = 8, VPX_BITS_10 = 10, VPX_BITS_12 = 12, }
pub use self::vpx_bit_depth as vpx_bit_depth_t;
extern "C" {
    /* \brief Return the version information (as an integer)
 *
 * Returns a packed encoding of the library version number. This will only
 * include
 * the major.minor.patch component of the version number. Note that this encoded
 * value should be accessed through the macros provided, as the encoding may
 * change
 * in the future.
 *
 */
    pub fn vpx_codec_version() -> ::std::os::raw::c_int;
}
extern "C" {
    /* \brief Return the version information (as a string)
 *
 * Returns a printable string containing the full library version number. This
 * may
 * contain additional text following the three digit version number, as to
 * indicate
 * release candidates, prerelease versions, etc.
 *
 */
    pub fn vpx_codec_version_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Return the version information (as a string)
 *
 * Returns a printable "extra string". This is the component of the string
 * returned
 * by vpx_codec_version_str() following the three digit version number.
 *
 */
    pub fn vpx_codec_version_extra_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Return the build configuration
 *
 * Returns a printable string containing an encoded version of the build
 * configuration. This may be useful to vpx support.
 *
 */
    pub fn vpx_codec_build_config() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Return the name for a given interface
 *
 * Returns a human readable string for name of the given codec interface.
 *
 * \param[in]    iface     Interface pointer
 *
 */
    pub fn vpx_codec_iface_name(iface: *mut vpx_codec_iface_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Convert error number to printable string
 *
 * Returns a human readable string for the last error returned by the
 * algorithm. The returned error will be one line and will not contain
 * any newline characters.
 *
 *
 * \param[in]    err     Error number.
 *
 */
    pub fn vpx_codec_err_to_string(err: vpx_codec_err_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Retrieve error synopsis for codec context
 *
 * Returns a human readable string for the last error returned by the
 * algorithm. The returned error will be one line and will not contain
 * any newline characters.
 *
 *
 * \param[in]    ctx     Pointer to this instance's context.
 *
 */
    pub fn vpx_codec_error(ctx: *mut vpx_codec_ctx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Retrieve detailed error information for codec context
 *
 * Returns a human readable string providing detailed information about
 * the last error.
 *
 * \param[in]    ctx     Pointer to this instance's context.
 *
 * \retval NULL
 *     No detailed information is available.
 */
    pub fn vpx_codec_error_detail(ctx: *mut vpx_codec_ctx_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /* \brief Destroy a codec instance
 *
 * Destroys a codec context, freeing any associated memory buffers.
 *
 * \param[in] ctx   Pointer to this instance's context
 *
 * \retval #VPX_CODEC_OK
 *     The codec algorithm initialized.
 * \retval #VPX_CODEC_MEM_ERROR
 *     Memory allocation failed.
 */
    pub fn vpx_codec_destroy(ctx: *mut vpx_codec_ctx_t) -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Get the capabilities of an algorithm.
 *
 * Retrieves the capabilities bitfield from the algorithm's interface.
 *
 * \param[in] iface   Pointer to the algorithm interface
 *
 */
    pub fn vpx_codec_get_caps(iface: *mut vpx_codec_iface_t)
     -> vpx_codec_caps_t;
}
extern "C" {
    /* \brief Control algorithm
 *
 * This function is used to exchange algorithm specific data with the codec
 * instance. This can be used to implement features specific to a particular
 * algorithm.
 *
 * This wrapper function dispatches the request to the helper function
 * associated with the given ctrl_id. It tries to call this function
 * transparently, but will return #VPX_CODEC_ERROR if the request could not
 * be dispatched.
 *
 * Note that this function should not be used directly. Call the
 * #vpx_codec_control wrapper macro instead.
 *
 * \param[in]     ctx              Pointer to this instance's context
 * \param[in]     ctrl_id          Algorithm specific control identifier
 *
 * \retval #VPX_CODEC_OK
 *     The control request was processed.
 * \retval #VPX_CODEC_ERROR
 *     The control request was not processed.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     The data was not valid.
 */
    pub fn vpx_codec_control_(ctx: *mut vpx_codec_ctx_t,
                              ctrl_id: ::std::os::raw::c_int, ...)
     -> vpx_codec_err_t;
}
#[repr(u32)]
/* \brief Control functions
 *
 * The set of macros define the control functions of VP8 interface
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vp8_com_control_id {
    VP8_SET_REFERENCE = 1,
    VP8_COPY_REFERENCE = 2,
    VP8_SET_POSTPROC = 3,
    VP8_SET_DBG_COLOR_REF_FRAME = 4,
    VP8_SET_DBG_COLOR_MB_MODES = 5,
    VP8_SET_DBG_COLOR_B_MODES = 6,
    VP8_SET_DBG_DISPLAY_MV = 7,
    VP9_GET_REFERENCE = 128,
    VP8_COMMON_CTRL_ID_MAX = 129,
    VP8_DECODER_CTRL_ID_START = 256,
}
#[repr(u32)]
/* \brief post process flags
 *
 * The set of macros define VP8 decoder post processing flags
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vp8_postproc_level {
    VP8_NOFILTERING = 0,
    VP8_DEBLOCK = 1,
    VP8_DEMACROBLOCK = 2,
    VP8_ADDNOISE = 4,
    VP8_DEBUG_TXT_FRAME_INFO = 8,
    VP8_DEBUG_TXT_MBLK_MODES = 16,
    VP8_DEBUG_TXT_DC_DIFF = 32,
    VP8_DEBUG_TXT_RATE_INFO = 64,
    VP8_MFQE = 1024,
}
/* \brief post process flags
 *
 * This define a structure that describe the post processing settings. For
 * the best objective measure (using the PSNR metric) set post_proc_flag
 * to VP8_DEBLOCK and deblocking_level to 1.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vp8_postproc_cfg {
    /* \brief the types of post processing to be done, should be combination of
   * "vp8_postproc_level" */
    pub post_proc_flag: ::std::os::raw::c_int,
    /**< the strength of deblocking, valid range [0, 16] */
    pub deblocking_level: ::std::os::raw::c_int,
    /**< the strength of additive noise, valid range [0, 16] */
    pub noise_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vp8_postproc_cfg() {
    assert_eq!(::std::mem::size_of::<vp8_postproc_cfg>() , 12usize);
    assert_eq!(::std::mem::align_of::<vp8_postproc_cfg>() , 4usize);
}
impl Clone for vp8_postproc_cfg {
    fn clone(&self) -> Self { *self }
}
pub type vp8_postproc_cfg_t = vp8_postproc_cfg;
#[repr(u32)]
/* \brief reference frame type
 *
 * The set of macros define the type of VP8 reference frames
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_ref_frame_type {
    VP8_LAST_FRAME = 1,
    VP8_GOLD_FRAME = 2,
    VP8_ALTR_FRAME = 4,
}
pub use self::vpx_ref_frame_type as vpx_ref_frame_type_t;
/* \brief reference frame data struct
 *
 * Define the data struct to access vp8 reference frames.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_ref_frame {
    /**< which reference frame */
    pub frame_type: vpx_ref_frame_type_t,
    /**< reference frame data in image format */
    pub img: vpx_image_t,
}
#[test]
fn bindgen_test_layout_vpx_ref_frame() {
    assert_eq!(::std::mem::size_of::<vpx_ref_frame>() , 144usize);
    assert_eq!(::std::mem::align_of::<vpx_ref_frame>() , 8usize);
}
impl Clone for vpx_ref_frame {
    fn clone(&self) -> Self { *self }
}
pub type vpx_ref_frame_t = vpx_ref_frame;
/* \brief VP9 specific reference frame data struct
 *
 * Define the data struct to access vp9 reference frames.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vp9_ref_frame {
    /**< frame index to get (input) */
    pub idx: ::std::os::raw::c_int,
    /**< img structure to populate (output) */
    pub img: vpx_image_t,
}
#[test]
fn bindgen_test_layout_vp9_ref_frame() {
    assert_eq!(::std::mem::size_of::<vp9_ref_frame>() , 144usize);
    assert_eq!(::std::mem::align_of::<vp9_ref_frame>() , 8usize);
}
impl Clone for vp9_ref_frame {
    fn clone(&self) -> Self { *self }
}
pub type vp9_ref_frame_t = vp9_ref_frame;
/* \brief Generic fixed size buffer structure
 *
 * This structure is able to hold a reference to any fixed size buffer.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_fixed_buf {
    /**< Pointer to the data */
    pub buf: *mut ::std::os::raw::c_void,
    /**< Length of the buffer, in chars */
    pub sz: usize,
}
#[test]
fn bindgen_test_layout_vpx_fixed_buf() {
    assert_eq!(::std::mem::size_of::<vpx_fixed_buf>() , 16usize);
    assert_eq!(::std::mem::align_of::<vpx_fixed_buf>() , 8usize);
}
impl Clone for vpx_fixed_buf {
    fn clone(&self) -> Self { *self }
}
pub type vpx_fixed_buf_t = vpx_fixed_buf;
/* \brief Time Stamp Type
 *
 * An integer, which when multiplied by the stream's time base, provides
 * the absolute time of a sample.
 */
pub type vpx_codec_pts_t = i64;
/* \brief Compressed Frame Flags
 *
 * This type represents a bitfield containing information about a compressed
 * frame that may be useful to an application. The most significant 16 bits
 * can be used by an algorithm to provide additional detail, for example to
 * support frame types that are codec specific (MPEG-1 D-frames for example)
 */
pub type vpx_codec_frame_flags_t = u32;
/* \brief Error Resilient flags
 *
 * These flags define which error resilient features to enable in the
 * encoder. The flags are specified through the
 * vpx_codec_enc_cfg::g_error_resilient variable.
 */
pub type vpx_codec_er_flags_t = u32;
#[repr(u32)]
/* \brief Encoder output packet variants
 *
 * This enumeration lists the different kinds of data packets that can be
 * returned by calls to vpx_codec_get_cx_data(). Algorithms \ref MAY
 * extend this list to provide additional functionality.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_codec_cx_pkt_kind {
    VPX_CODEC_CX_FRAME_PKT = 0,
    VPX_CODEC_STATS_PKT = 1,
    VPX_CODEC_FPMB_STATS_PKT = 2,
    VPX_CODEC_PSNR_PKT = 3,
    VPX_CODEC_CUSTOM_PKT = 256,
}
/* \brief Encoder output packet
 *
 * This structure contains the different kinds of output data the encoder
 * may produce while compressing a frame.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_cx_pkt {
    /**< packet variant */
    pub kind: vpx_codec_cx_pkt_kind,
    /**< packet data */
    pub data: vpx_codec_cx_pkt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_cx_pkt__bindgen_ty_1 {
    /**< data for compressed frame packet */
    pub frame: __BindgenUnionField<vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1>,
    /**< data for two-pass packet */
    pub twopass_stats: __BindgenUnionField<vpx_fixed_buf_t>,
    /**< first pass mb packet */
    pub firstpass_mb_stats: __BindgenUnionField<vpx_fixed_buf_t>,
    /**< data for PSNR packet */
    pub psnr: __BindgenUnionField<vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt>,
    /**< data for arbitrary packets */
    pub raw: __BindgenUnionField<vpx_fixed_buf_t>,
    /**< fixed sz */
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 124usize]>,
    pub bindgen_union_field: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1 {
    /**< compressed data buffer */
    pub buf: *mut ::std::os::raw::c_void,
    /**< length of compressed data */
    pub sz: usize,
    /* \brief time stamp to show frame (in timebase units) */
    pub pts: vpx_codec_pts_t,
    /* \brief duration to show frame (in timebase units) */
    pub duration: ::std::os::raw::c_ulong,
    /**< flags for this frame */
    pub flags: vpx_codec_frame_flags_t,
    /* \brief the partition id defines the decoding order of the partitions.
       * Only applicable when "output partition" mode is enabled. First
       * partition has id 0.*/
    pub partition_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1>()
               , 40usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for vpx_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt {
    /**< Number of samples, total/y/u/v */
    pub samples: [::std::os::raw::c_uint; 4usize],
    /**< sum squared error, total/y/u/v */
    pub sse: [u64; 4usize],
    /**< PSNR, total/y/u/v */
    pub psnr: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt() {
    assert_eq!(::std::mem::size_of::<vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt>()
               , 80usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt>()
               , 8usize);
}
impl Clone for vpx_codec_cx_pkt__bindgen_ty_1_vpx_psnr_pkt {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_vpx_codec_cx_pkt__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<vpx_codec_cx_pkt__bindgen_ty_1>() ,
               128usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_cx_pkt__bindgen_ty_1>() ,
               8usize);
}
impl Clone for vpx_codec_cx_pkt__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_vpx_codec_cx_pkt() {
    assert_eq!(::std::mem::size_of::<vpx_codec_cx_pkt>() , 136usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_cx_pkt>() , 8usize);
}
impl Clone for vpx_codec_cx_pkt {
    fn clone(&self) -> Self { *self }
}
pub type vpx_codec_cx_pkt_t = vpx_codec_cx_pkt;
/* \brief Encoder return output buffer callback
 *
 * This callback function, when registered, returns with packets when each
 * spatial layer is encoded.
 */
pub type vpx_codec_enc_output_cx_pkt_cb_fn_t =
    ::std::option::Option<unsafe extern "C" fn(pkt: *mut vpx_codec_cx_pkt_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)>;
/* \brief Callback function pointer / user data pair storage */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_enc_output_cx_cb_pair {
    /**< Callback function */
    pub output_cx_pkt: vpx_codec_enc_output_cx_pkt_cb_fn_t,
    /**< Pointer to private data */
    pub user_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_codec_enc_output_cx_cb_pair() {
    assert_eq!(::std::mem::size_of::<vpx_codec_enc_output_cx_cb_pair>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_enc_output_cx_cb_pair>() ,
               8usize);
}
impl Clone for vpx_codec_enc_output_cx_cb_pair {
    fn clone(&self) -> Self { *self }
}
pub type vpx_codec_priv_output_cx_pkt_cb_pair_t =
    vpx_codec_enc_output_cx_cb_pair;
/* \brief Rational Number
 *
 * This structure holds a fractional value.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_rational {
    /**< fraction numerator */
    pub num: ::std::os::raw::c_int,
    /**< fraction denominator */
    pub den: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpx_rational() {
    assert_eq!(::std::mem::size_of::<vpx_rational>() , 8usize);
    assert_eq!(::std::mem::align_of::<vpx_rational>() , 4usize);
}
impl Clone for vpx_rational {
    fn clone(&self) -> Self { *self }
}
pub type vpx_rational_t = vpx_rational;
#[repr(u32)]
/* \brief Multi-pass Encoding Pass */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_enc_pass {
    VPX_RC_ONE_PASS = 0,
    VPX_RC_FIRST_PASS = 1,
    VPX_RC_LAST_PASS = 2,
}
#[repr(u32)]
/* \brief Rate control mode */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_rc_mode { VPX_VBR = 0, VPX_CBR = 1, VPX_CQ = 2, VPX_Q = 3, }
pub const vpx_kf_mode_VPX_KF_DISABLED: vpx_kf_mode =
    vpx_kf_mode::VPX_KF_FIXED;
#[repr(u32)]
/* \brief Keyframe placement mode.
 *
 * This enumeration determines whether keyframes are placed automatically by
 * the encoder or whether this behavior is disabled. Older releases of this
 * SDK were implemented such that VPX_KF_FIXED meant keyframes were disabled.
 * This name is confusing for this behavior, so the new symbols to be used
 * are VPX_KF_AUTO and VPX_KF_DISABLED.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_kf_mode { VPX_KF_FIXED = 0, VPX_KF_AUTO = 1, }
/* \brief Encoded Frame Flags
 *
 * This type indicates a bitfield to be passed to vpx_codec_encode(), defining
 * per-frame boolean values. By convention, bits common to all codecs will be
 * named VPX_EFLAG_*, and bits specific to an algorithm will be named
 * /algo/_eflag_*. The lower order 16 bits are reserved for common use.
 */
pub type vpx_enc_frame_flags_t = ::std::os::raw::c_long;
pub type vpx_codec_enc_cfg_t = vpx_codec_ctx__bindgen_ty_1_vpx_codec_enc_cfg;
/* \brief  vp9 svc extra configure parameters
 *
 * This defines max/min quantizers and scale factors for each layer
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_svc_parameters {
    /**< Max Q for each layer */
    pub max_quantizers: [::std::os::raw::c_int; 12usize],
    /**< Min Q for each layer */
    pub min_quantizers: [::std::os::raw::c_int; 12usize],
    /**< Scaling factor-numerator */
    pub scaling_factor_num: [::std::os::raw::c_int; 12usize],
    /**< Scaling factor-denominator */
    pub scaling_factor_den: [::std::os::raw::c_int; 12usize],
    /**< Speed setting for each sl */
    pub speed_per_layer: [::std::os::raw::c_int; 12usize],
    /**< Temporal layering mode */
    pub temporal_layering_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpx_svc_parameters() {
    assert_eq!(::std::mem::size_of::<vpx_svc_parameters>() , 244usize);
    assert_eq!(::std::mem::align_of::<vpx_svc_parameters>() , 4usize);
}
impl Clone for vpx_svc_parameters {
    fn clone(&self) -> Self { *self }
}
pub type vpx_svc_extra_cfg_t = vpx_svc_parameters;
extern "C" {
    /* \brief Initialize an encoder instance
 *
 * Initializes a encoder context using the given interface. Applications
 * should call the vpx_codec_enc_init convenience macro instead of this
 * function directly, to ensure that the ABI version number parameter
 * is properly initialized.
 *
 * If the library was configured with --disable-multithread, this call
 * is not thread safe and should be guarded with a lock if being used
 * in a multithreaded context.
 *
 * \param[in]    ctx     Pointer to this instance's context.
 * \param[in]    iface   Pointer to the algorithm interface to use.
 * \param[in]    cfg     Configuration to use, if known. May be NULL.
 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
 * \param[in]    ver     ABI version number. Must be set to
 *                       VPX_ENCODER_ABI_VERSION
 * \retval #VPX_CODEC_OK
 *     The decoder algorithm initialized.
 * \retval #VPX_CODEC_MEM_ERROR
 *     Memory allocation failed.
 */
    pub fn vpx_codec_enc_init_ver(ctx: *mut vpx_codec_ctx_t,
                                  iface: *mut vpx_codec_iface_t,
                                  cfg: *const vpx_codec_enc_cfg_t,
                                  flags: vpx_codec_flags_t,
                                  ver: ::std::os::raw::c_int)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Initialize multi-encoder instance
 *
 * Initializes multi-encoder context using the given interface.
 * Applications should call the vpx_codec_enc_init_multi convenience macro
 * instead of this function directly, to ensure that the ABI version number
 * parameter is properly initialized.
 *
 * \param[in]    ctx     Pointer to this instance's context.
 * \param[in]    iface   Pointer to the algorithm interface to use.
 * \param[in]    cfg     Configuration to use, if known. May be NULL.
 * \param[in]    num_enc Total number of encoders.
 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
 * \param[in]    dsf     Pointer to down-sampling factors.
 * \param[in]    ver     ABI version number. Must be set to
 *                       VPX_ENCODER_ABI_VERSION
 * \retval #VPX_CODEC_OK
 *     The decoder algorithm initialized.
 * \retval #VPX_CODEC_MEM_ERROR
 *     Memory allocation failed.
 */
    pub fn vpx_codec_enc_init_multi_ver(ctx: *mut vpx_codec_ctx_t,
                                        iface: *mut vpx_codec_iface_t,
                                        cfg: *mut vpx_codec_enc_cfg_t,
                                        num_enc: ::std::os::raw::c_int,
                                        flags: vpx_codec_flags_t,
                                        dsf: *mut vpx_rational_t,
                                        ver: ::std::os::raw::c_int)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Get a default configuration
 *
 * Initializes a encoder configuration structure with default values. Supports
 * the notion of "usages" so that an algorithm may offer different default
 * settings depending on the user's intended goal. This function \ref SHOULD
 * be called by all applications to initialize the configuration structure
 * before specializing the configuration with application specific values.
 *
 * \param[in]    iface     Pointer to the algorithm interface to use.
 * \param[out]   cfg       Configuration buffer to populate.
 * \param[in]    reserved  Must set to 0 for VP8 and VP9.
 *
 * \retval #VPX_CODEC_OK
 *     The configuration was populated.
 * \retval #VPX_CODEC_INCAPABLE
 *     Interface is not an encoder interface.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     A parameter was NULL, or the usage value was not recognized.
 */
    pub fn vpx_codec_enc_config_default(iface: *mut vpx_codec_iface_t,
                                        cfg: *mut vpx_codec_enc_cfg_t,
                                        reserved: ::std::os::raw::c_uint)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Set or change configuration
 *
 * Reconfigures an encoder instance according to the given configuration.
 *
 * \param[in]    ctx     Pointer to this instance's context
 * \param[in]    cfg     Configuration buffer to use
 *
 * \retval #VPX_CODEC_OK
 *     The configuration was populated.
 * \retval #VPX_CODEC_INCAPABLE
 *     Interface is not an encoder interface.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     A parameter was NULL, or the usage value was not recognized.
 */
    pub fn vpx_codec_enc_config_set(ctx: *mut vpx_codec_ctx_t,
                                    cfg: *const vpx_codec_enc_cfg_t)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Get global stream headers
 *
 * Retrieves a stream level global header packet, if supported by the codec.
 *
 * \param[in]    ctx     Pointer to this instance's context
 *
 * \retval NULL
 *     Encoder does not support global header
 * \retval Non-NULL
 *     Pointer to buffer containing global header packet
 */
    pub fn vpx_codec_get_global_headers(ctx: *mut vpx_codec_ctx_t)
     -> *mut vpx_fixed_buf_t;
}
extern "C" {
    /* \brief Encode a frame
 *
 * Encodes a video frame at the given "presentation time." The presentation
 * time stamp (PTS) \ref MUST be strictly increasing.
 *
 * The encoder supports the notion of a soft real-time deadline. Given a
 * non-zero value to the deadline parameter, the encoder will make a "best
 * effort" guarantee to  return before the given time slice expires. It is
 * implicit that limiting the available time to encode will degrade the
 * output quality. The encoder can be given an unlimited time to produce the
 * best possible frame by specifying a deadline of '0'. This deadline
 * supercedes the VPx notion of "best quality, good quality, realtime".
 * Applications that wish to map these former settings to the new deadline
 * based system can use the symbols #VPX_DL_REALTIME, #VPX_DL_GOOD_QUALITY,
 * and #VPX_DL_BEST_QUALITY.
 *
 * When the last frame has been passed to the encoder, this function should
 * continue to be called, with the img parameter set to NULL. This will
 * signal the end-of-stream condition to the encoder and allow it to encode
 * any held buffers. Encoding is complete when vpx_codec_encode() is called
 * and vpx_codec_get_cx_data() returns no data.
 *
 * \param[in]    ctx       Pointer to this instance's context
 * \param[in]    img       Image data to encode, NULL to flush.
 * \param[in]    pts       Presentation time stamp, in timebase units.
 * \param[in]    duration  Duration to show frame, in timebase units.
 * \param[in]    flags     Flags to use for encoding this frame.
 * \param[in]    deadline  Time to spend encoding, in microseconds. (0=infinite)
 *
 * \retval #VPX_CODEC_OK
 *     The configuration was populated.
 * \retval #VPX_CODEC_INCAPABLE
 *     Interface is not an encoder interface.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     A parameter was NULL, the image format is unsupported, etc.
 */
    pub fn vpx_codec_encode(ctx: *mut vpx_codec_ctx_t,
                            img: *const vpx_image_t, pts: vpx_codec_pts_t,
                            duration: ::std::os::raw::c_ulong,
                            flags: vpx_enc_frame_flags_t,
                            deadline: ::std::os::raw::c_ulong)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Set compressed data output buffer
 *
 * Sets the buffer that the codec should output the compressed data
 * into. This call effectively sets the buffer pointer returned in the
 * next VPX_CODEC_CX_FRAME_PKT packet. Subsequent packets will be
 * appended into this buffer. The buffer is preserved across frames,
 * so applications must periodically call this function after flushing
 * the accumulated compressed data to disk or to the network to reset
 * the pointer to the buffer's head.
 *
 * `pad_before` bytes will be skipped before writing the compressed
 * data, and `pad_after` bytes will be appended to the packet. The size
 * of the packet will be the sum of the size of the actual compressed
 * data, pad_before, and pad_after. The padding bytes will be preserved
 * (not overwritten).
 *
 * Note that calling this function does not guarantee that the returned
 * compressed data will be placed into the specified buffer. In the
 * event that the encoded data will not fit into the buffer provided,
 * the returned packet \ref MAY point to an internal buffer, as it would
 * if this call were never used. In this event, the output packet will
 * NOT have any padding, and the application must free space and copy it
 * to the proper place. This is of particular note in configurations
 * that may output multiple packets for a single encoded frame (e.g., lagged
 * encoding) or if the application does not reset the buffer periodically.
 *
 * Applications may restore the default behavior of the codec providing
 * the compressed data buffer by calling this function with a NULL
 * buffer.
 *
 * Applications \ref MUSTNOT call this function during iteration of
 * vpx_codec_get_cx_data().
 *
 * \param[in]    ctx         Pointer to this instance's context
 * \param[in]    buf         Buffer to store compressed data into
 * \param[in]    pad_before  Bytes to skip before writing compressed data
 * \param[in]    pad_after   Bytes to skip after writing compressed data
 *
 * \retval #VPX_CODEC_OK
 *     The buffer was set successfully.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     A parameter was NULL, the image format is unsupported, etc.
 */
    pub fn vpx_codec_set_cx_data_buf(ctx: *mut vpx_codec_ctx_t,
                                     buf: *const vpx_fixed_buf_t,
                                     pad_before: ::std::os::raw::c_uint,
                                     pad_after: ::std::os::raw::c_uint)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Encoded data iterator
 *
 * Iterates over a list of data packets to be passed from the encoder to the
 * application. The different kinds of packets available are enumerated in
 * #vpx_codec_cx_pkt_kind.
 *
 * #VPX_CODEC_CX_FRAME_PKT packets should be passed to the application's
 * muxer. Multiple compressed frames may be in the list.
 * #VPX_CODEC_STATS_PKT packets should be appended to a global buffer.
 *
 * The application \ref MUST silently ignore any packet kinds that it does
 * not recognize or support.
 *
 * The data buffers returned from this function are only guaranteed to be
 * valid until the application makes another call to any vpx_codec_* function.
 *
 * \param[in]     ctx      Pointer to this instance's context
 * \param[in,out] iter     Iterator storage, initialized to NULL
 *
 * \return Returns a pointer to an output data packet (compressed frame data,
 *         two-pass statistics, etc.) or NULL to signal end-of-list.
 *
 */
    pub fn vpx_codec_get_cx_data(ctx: *mut vpx_codec_ctx_t,
                                 iter: *mut vpx_codec_iter_t)
     -> *const vpx_codec_cx_pkt_t;
}
extern "C" {
    /* \brief Get Preview Frame
 *
 * Returns an image that can be used as a preview. Shows the image as it would
 * exist at the decompressor. The application \ref MUST NOT write into this
 * image buffer.
 *
 * \param[in]     ctx      Pointer to this instance's context
 *
 * \return Returns a pointer to a preview image, or NULL if no image is
 *         available.
 *
 */
    pub fn vpx_codec_get_preview_frame(ctx: *mut vpx_codec_ctx_t)
     -> *const vpx_image_t;
}
extern "C" {
    #[link_name = "vpx_codec_vp8_cx_algo"]
    pub static mut vpx_codec_vp8_cx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp8_cx() -> *mut vpx_codec_iface_t;
}
extern "C" {
    #[link_name = "vpx_codec_vp9_cx_algo"]
    pub static mut vpx_codec_vp9_cx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp9_cx() -> *mut vpx_codec_iface_t;
}
#[repr(u32)]
/* \brief VPx encoder control functions
 *
 * This set of macros define the control functions available for VPx
 * encoder interface.
 *
 * \sa #vpx_codec_control
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vp8e_enc_control_id {
    VP8E_SET_ROI_MAP = 8,
    VP8E_SET_ACTIVEMAP = 9,
    VP8E_SET_SCALEMODE = 11,
    VP8E_SET_CPUUSED = 13,
    VP8E_SET_ENABLEAUTOALTREF = 14,
    VP8E_SET_NOISE_SENSITIVITY = 15,
    VP8E_SET_SHARPNESS = 16,
    VP8E_SET_STATIC_THRESHOLD = 17,
    VP8E_SET_TOKEN_PARTITIONS = 18,
    VP8E_GET_LAST_QUANTIZER = 19,
    VP8E_GET_LAST_QUANTIZER_64 = 20,
    VP8E_SET_ARNR_MAXFRAMES = 21,
    VP8E_SET_ARNR_STRENGTH = 22,
    VP8E_SET_ARNR_TYPE = 23,
    VP8E_SET_TUNING = 24,
    VP8E_SET_CQ_LEVEL = 25,
    VP8E_SET_MAX_INTRA_BITRATE_PCT = 26,
    VP8E_SET_FRAME_FLAGS = 27,
    VP9E_SET_MAX_INTER_BITRATE_PCT = 28,
    VP9E_SET_GF_CBR_BOOST_PCT = 29,
    VP8E_SET_TEMPORAL_LAYER_ID = 30,
    VP8E_SET_SCREEN_CONTENT_MODE = 31,
    VP9E_SET_LOSSLESS = 32,
    VP9E_SET_TILE_COLUMNS = 33,
    VP9E_SET_TILE_ROWS = 34,
    VP9E_SET_FRAME_PARALLEL_DECODING = 35,
    VP9E_SET_AQ_MODE = 36,
    VP9E_SET_FRAME_PERIODIC_BOOST = 37,
    VP9E_SET_NOISE_SENSITIVITY = 38,
    VP9E_SET_SVC = 39,
    VP9E_SET_SVC_PARAMETERS = 40,
    VP9E_SET_SVC_LAYER_ID = 41,
    VP9E_SET_TUNE_CONTENT = 42,
    VP9E_GET_SVC_LAYER_ID = 43,
    VP9E_REGISTER_CX_CALLBACK = 44,
    VP9E_SET_COLOR_SPACE = 45,
    VP9E_SET_TEMPORAL_LAYERING_MODE = 46,
    VP9E_SET_MIN_GF_INTERVAL = 47,
    VP9E_SET_MAX_GF_INTERVAL = 48,
    VP9E_GET_ACTIVEMAP = 49,
    VP9E_SET_COLOR_RANGE = 50,
    VP9E_SET_SVC_REF_FRAME_CONFIG = 51,
    VP9E_SET_RENDER_SIZE = 52,
    VP9E_SET_TARGET_LEVEL = 53,
    VP9E_GET_LEVEL = 54,
    VP9E_SET_ALT_REF_AQ = 55,
    VP8E_SET_GF_CBR_BOOST_PCT = 56,
}
#[repr(u32)]
/* \brief vpx 1-D scaling mode
 *
 * This set of constants define 1-D vpx scaling modes
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vpx_scaling_mode_1d {
    VP8E_NORMAL = 0,
    VP8E_FOURFIVE = 1,
    VP8E_THREEFIVE = 2,
    VP8E_ONETWO = 3,
}
pub use self::vpx_scaling_mode_1d as VPX_SCALING_MODE;
#[repr(u32)]
/* \brief Temporal layering mode enum for VP9 SVC.
 *
 * This set of macros define the different temporal layering modes.
 * Supported codecs: VP9 (in SVC mode)
 *
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vp9e_temporal_layering_mode {
    VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING = 0,
    VP9E_TEMPORAL_LAYERING_MODE_BYPASS = 1,
    VP9E_TEMPORAL_LAYERING_MODE_0101 = 2,
    VP9E_TEMPORAL_LAYERING_MODE_0212 = 3,
}
pub use self::vp9e_temporal_layering_mode as VP9E_TEMPORAL_LAYERING_MODE;
/* \brief  vpx region of interest map
 *
 * These defines the data structures for the region of interest map
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_roi_map {
    /*  An id between 0 and 3 for each 16x16 region within a frame. */
    pub roi_map: *mut ::std::os::raw::c_uchar,
    /**< Number of rows. */
    pub rows: ::std::os::raw::c_uint,
    /**< Number of columns. */
    pub cols: ::std::os::raw::c_uint,
    /**< Quantizer deltas. */
    pub delta_q: [::std::os::raw::c_int; 4usize],
    /**< Loop filter deltas. */
    pub delta_lf: [::std::os::raw::c_int; 4usize],
    /*  Static breakout threshold for each segment. */
    pub static_threshold: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_vpx_roi_map() {
    assert_eq!(::std::mem::size_of::<vpx_roi_map>() , 64usize);
    assert_eq!(::std::mem::align_of::<vpx_roi_map>() , 8usize);
}
impl Clone for vpx_roi_map {
    fn clone(&self) -> Self { *self }
}
pub type vpx_roi_map_t = vpx_roi_map;
/* \brief  vpx active region map
 *
 * These defines the data structures for active region map
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_active_map {
    /* \brief specify an on (1) or off (0) each 16x16 region within a frame */
    pub active_map: *mut ::std::os::raw::c_uchar,
    /**< number of rows */
    pub rows: ::std::os::raw::c_uint,
    /**< number of cols */
    pub cols: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_active_map() {
    assert_eq!(::std::mem::size_of::<vpx_active_map>() , 16usize);
    assert_eq!(::std::mem::align_of::<vpx_active_map>() , 8usize);
}
impl Clone for vpx_active_map {
    fn clone(&self) -> Self { *self }
}
pub type vpx_active_map_t = vpx_active_map;
/* \brief  vpx image scaling mode
 *
 * This defines the data structure for image scaling mode
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_scaling_mode {
    /**< horizontal scaling mode */
    pub h_scaling_mode: VPX_SCALING_MODE,
    /**< vertical scaling mode   */
    pub v_scaling_mode: VPX_SCALING_MODE,
}
#[test]
fn bindgen_test_layout_vpx_scaling_mode() {
    assert_eq!(::std::mem::size_of::<vpx_scaling_mode>() , 8usize);
    assert_eq!(::std::mem::align_of::<vpx_scaling_mode>() , 4usize);
}
impl Clone for vpx_scaling_mode {
    fn clone(&self) -> Self { *self }
}
pub type vpx_scaling_mode_t = vpx_scaling_mode;
pub const VP8_ONE_TOKENPARTITION: _bindgen_ty_4 =
    _bindgen_ty_4::VP8_ONE_TOKENPARTITION;
pub const VP8_TWO_TOKENPARTITION: _bindgen_ty_4 =
    _bindgen_ty_4::VP8_TWO_TOKENPARTITION;
pub const VP8_FOUR_TOKENPARTITION: _bindgen_ty_4 =
    _bindgen_ty_4::VP8_FOUR_TOKENPARTITION;
pub const VP8_EIGHT_TOKENPARTITION: _bindgen_ty_4 =
    _bindgen_ty_4::VP8_EIGHT_TOKENPARTITION;
#[repr(u32)]
/* \brief VP8 token partition mode
 *
 * This defines VP8 partitioning mode for compressed data, i.e., the number of
 * sub-streams in the bitstream. Used for parallelized decoding.
 *
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    VP8_ONE_TOKENPARTITION = 0,
    VP8_TWO_TOKENPARTITION = 1,
    VP8_FOUR_TOKENPARTITION = 2,
    VP8_EIGHT_TOKENPARTITION = 3,
}
pub use self::_bindgen_ty_4 as vp8e_token_partitions;
pub const VP9E_CONTENT_DEFAULT: _bindgen_ty_5 =
    _bindgen_ty_5::VP9E_CONTENT_DEFAULT;
pub const VP9E_CONTENT_SCREEN: _bindgen_ty_5 =
    _bindgen_ty_5::VP9E_CONTENT_SCREEN;
pub const VP9E_CONTENT_INVALID: _bindgen_ty_5 =
    _bindgen_ty_5::VP9E_CONTENT_INVALID;
#[repr(u32)]
/* brief VP9 encoder content type */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    VP9E_CONTENT_DEFAULT = 0,
    VP9E_CONTENT_SCREEN = 1,
    VP9E_CONTENT_INVALID = 2,
}
pub use self::_bindgen_ty_5 as vp9e_tune_content;
pub const VP8_TUNE_PSNR: _bindgen_ty_6 = _bindgen_ty_6::VP8_TUNE_PSNR;
pub const VP8_TUNE_SSIM: _bindgen_ty_6 = _bindgen_ty_6::VP8_TUNE_SSIM;
#[repr(u32)]
/* \brief VP8 model tuning parameters
 *
 * Changes the encoder to tune for certain types of input material.
 *
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 { VP8_TUNE_PSNR = 0, VP8_TUNE_SSIM = 1, }
pub use self::_bindgen_ty_6 as vp8e_tuning;
/* \brief  vp9 svc layer parameters
 *
 * This defines the spatial and temporal layer id numbers for svc encoding.
 * This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and
 * temporal layer id for the current frame.
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_svc_layer_id {
    /**< Spatial layer id number. */
    pub spatial_layer_id: ::std::os::raw::c_int,
    /**< Temporal layer id number. */
    pub temporal_layer_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpx_svc_layer_id() {
    assert_eq!(::std::mem::size_of::<vpx_svc_layer_id>() , 8usize);
    assert_eq!(::std::mem::align_of::<vpx_svc_layer_id>() , 4usize);
}
impl Clone for vpx_svc_layer_id {
    fn clone(&self) -> Self { *self }
}
pub type vpx_svc_layer_id_t = vpx_svc_layer_id;
/* \brief  vp9 svc frame flag parameters.
 *
 * This defines the frame flags and buffer indices for each spatial layer for
 * svc encoding.
 * This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame
 * flags and buffer indices for each spatial layer for the current (super)frame.
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_svc_ref_frame_config {
    /**< Frame flags. */
    pub frame_flags: [::std::os::raw::c_int; 5usize],
    /**< Last buffer index. */
    pub lst_fb_idx: [::std::os::raw::c_int; 5usize],
    /**< Golden buffer index. */
    pub gld_fb_idx: [::std::os::raw::c_int; 5usize],
    /**< Altref buffer index. */
    pub alt_fb_idx: [::std::os::raw::c_int; 5usize],
}
#[test]
fn bindgen_test_layout_vpx_svc_ref_frame_config() {
    assert_eq!(::std::mem::size_of::<vpx_svc_ref_frame_config>() , 80usize);
    assert_eq!(::std::mem::align_of::<vpx_svc_ref_frame_config>() , 4usize);
}
impl Clone for vpx_svc_ref_frame_config {
    fn clone(&self) -> Self { *self }
}
pub type vpx_svc_ref_frame_config_t = vpx_svc_ref_frame_config;
extern "C" {
    #[link_name = "vpx_codec_vp8_dx_algo"]
    pub static mut vpx_codec_vp8_dx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp8_dx() -> *mut vpx_codec_iface_t;
}
extern "C" {
    #[link_name = "vpx_codec_vp9_dx_algo"]
    pub static mut vpx_codec_vp9_dx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp9_dx() -> *mut vpx_codec_iface_t;
}
pub const vp8_dec_control_id_VP8D_SET_DECRYPTOR: vp8_dec_control_id =
    vp8_dec_control_id::VPXD_SET_DECRYPTOR;
#[repr(u32)]
/* \enum vp8_dec_control_id
 * \brief VP8 decoder control functions
 *
 * This set of macros define the control functions available for the VP8
 * decoder interface.
 *
 * \sa #vpx_codec_control
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vp8_dec_control_id {
    VP8D_GET_LAST_REF_UPDATES = 256,
    VP8D_GET_FRAME_CORRUPTED = 257,
    VP8D_GET_LAST_REF_USED = 258,
    VPXD_SET_DECRYPTOR = 259,
    VP9D_GET_FRAME_SIZE = 260,
    VP9D_GET_DISPLAY_SIZE = 261,
    VP9D_GET_BIT_DEPTH = 262,
    VP9_SET_BYTE_ALIGNMENT = 263,
    VP9_INVERT_TILE_DECODE_ORDER = 264,
    VP9_SET_SKIP_LOOP_FILTER = 265,
    VP9_DECODE_SVC_SPATIAL_LAYER = 266,
    VP8_DECODER_CTRL_ID_MAX = 267,
}
/** Decrypt n bytes of data from input -> output, using the decrypt_state
 *  passed in VPXD_SET_DECRYPTOR.
 */
pub type vpx_decrypt_cb =
    ::std::option::Option<unsafe extern "C" fn(decrypt_state:
                                                   *mut ::std::os::raw::c_void,
                                               input:
                                                   *const ::std::os::raw::c_uchar,
                                               output:
                                                   *mut ::std::os::raw::c_uchar,
                                               count: ::std::os::raw::c_int)>;
/* \brief Structure to hold decryption state
 *
 * Defines a structure to hold the decryption state and access function.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_decrypt_init {
    /*  Decrypt callback. */
    pub decrypt_cb: vpx_decrypt_cb,
    /*  Decryption state. */
    pub decrypt_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_decrypt_init() {
    assert_eq!(::std::mem::size_of::<vpx_decrypt_init>() , 16usize);
    assert_eq!(::std::mem::align_of::<vpx_decrypt_init>() , 8usize);
}
impl Clone for vpx_decrypt_init {
    fn clone(&self) -> Self { *self }
}
/* \brief A deprecated alias for vpx_decrypt_init.
 */
pub type vp8_decrypt_init = vpx_decrypt_init;
/* \brief External frame buffer
 *
 * This structure holds allocated frame buffers used by the decoder.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_frame_buffer {
    /**< Pointer to the data buffer */
    pub data: *mut u8,
    /**< Size of data in bytes */
    pub size: usize,
    /**< Frame's private data */
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_codec_frame_buffer() {
    assert_eq!(::std::mem::size_of::<vpx_codec_frame_buffer>() , 24usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_frame_buffer>() , 8usize);
}
impl Clone for vpx_codec_frame_buffer {
    fn clone(&self) -> Self { *self }
}
pub type vpx_codec_frame_buffer_t = vpx_codec_frame_buffer;
/* \brief get frame buffer callback prototype
 *
 * This callback is invoked by the decoder to retrieve data for the frame
 * buffer in order for the decode call to complete. The callback must
 * allocate at least min_size in bytes and assign it to fb->data. The callback
 * must zero out all the data allocated. Then the callback must set fb->size
 * to the allocated size. The application does not need to align the allocated
 * data. The callback is triggered when the decoder needs a frame buffer to
 * decode a compressed image into. This function may be called more than once
 * for every call to vpx_codec_decode. The application may set fb->priv to
 * some data which will be passed back in the ximage and the release function
 * call. |fb| is guaranteed to not be NULL. On success the callback must
 * return 0. Any failure the callback must return a value less than 0.
 *
 * \param[in] priv         Callback's private data
 * \param[in] new_size     Size in bytes needed by the buffer
 * \param[in,out] fb       Pointer to vpx_codec_frame_buffer_t
 */
pub type vpx_get_frame_buffer_cb_fn_t =
    ::std::option::Option<unsafe extern "C" fn(priv_:
                                                   *mut ::std::os::raw::c_void,
                                               min_size: usize,
                                               fb:
                                                   *mut vpx_codec_frame_buffer_t)
                              -> ::std::os::raw::c_int>;
/* \brief release frame buffer callback prototype
 *
 * This callback is invoked by the decoder when the frame buffer is not
 * referenced by any other buffers. |fb| is guaranteed to not be NULL. On
 * success the callback must return 0. Any failure the callback must return
 * a value less than 0.
 *
 * \param[in] priv         Callback's private data
 * \param[in] fb           Pointer to vpx_codec_frame_buffer_t
 */
pub type vpx_release_frame_buffer_cb_fn_t =
    ::std::option::Option<unsafe extern "C" fn(priv_:
                                                   *mut ::std::os::raw::c_void,
                                               fb:
                                                   *mut vpx_codec_frame_buffer_t)
                              -> ::std::os::raw::c_int>;
/* \brief Stream properties
 *
 * This structure is used to query or set properties of the decoded
 * stream. Algorithms may extend this structure with data specific
 * to their bitstream by setting the sz member appropriately.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpx_codec_stream_info {
    /**< Size of this structure */
    pub sz: ::std::os::raw::c_uint,
    /**< Width (or 0 for unknown/default) */
    pub w: ::std::os::raw::c_uint,
    /**< Height (or 0 for unknown/default) */
    pub h: ::std::os::raw::c_uint,
    /**< Current frame is a keyframe */
    pub is_kf: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_codec_stream_info() {
    assert_eq!(::std::mem::size_of::<vpx_codec_stream_info>() , 16usize);
    assert_eq!(::std::mem::align_of::<vpx_codec_stream_info>() , 4usize);
}
impl Clone for vpx_codec_stream_info {
    fn clone(&self) -> Self { *self }
}
pub type vpx_codec_stream_info_t = vpx_codec_stream_info;
pub type vpx_codec_dec_cfg_t = vpx_codec_ctx__bindgen_ty_1_vpx_codec_dec_cfg;
extern "C" {
    /* \brief Initialize a decoder instance
 *
 * Initializes a decoder context using the given interface. Applications
 * should call the vpx_codec_dec_init convenience macro instead of this
 * function directly, to ensure that the ABI version number parameter
 * is properly initialized.
 *
 * If the library was configured with --disable-multithread, this call
 * is not thread safe and should be guarded with a lock if being used
 * in a multithreaded context.
 *
 * \param[in]    ctx     Pointer to this instance's context.
 * \param[in]    iface   Pointer to the algorithm interface to use.
 * \param[in]    cfg     Configuration to use, if known. May be NULL.
 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
 * \param[in]    ver     ABI version number. Must be set to
 *                       VPX_DECODER_ABI_VERSION
 * \retval #VPX_CODEC_OK
 *     The decoder algorithm initialized.
 * \retval #VPX_CODEC_MEM_ERROR
 *     Memory allocation failed.
 */
    pub fn vpx_codec_dec_init_ver(ctx: *mut vpx_codec_ctx_t,
                                  iface: *mut vpx_codec_iface_t,
                                  cfg: *const vpx_codec_dec_cfg_t,
                                  flags: vpx_codec_flags_t,
                                  ver: ::std::os::raw::c_int)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Parse stream info from a buffer
 *
 * Performs high level parsing of the bitstream. Construction of a decoder
 * context is not necessary. Can be used to determine if the bitstream is
 * of the proper format, and to extract information from the stream.
 *
 * \param[in]      iface   Pointer to the algorithm interface
 * \param[in]      data    Pointer to a block of data to parse
 * \param[in]      data_sz Size of the data buffer
 * \param[in,out]  si      Pointer to stream info to update. The size member
 *                         \ref MUST be properly initialized, but \ref MAY be
 *                         clobbered by the algorithm. This parameter \ref MAY
 *                         be NULL.
 *
 * \retval #VPX_CODEC_OK
 *     Bitstream is parsable and stream information updated
 */
    pub fn vpx_codec_peek_stream_info(iface: *mut vpx_codec_iface_t,
                                      data: *const u8,
                                      data_sz: ::std::os::raw::c_uint,
                                      si: *mut vpx_codec_stream_info_t)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Return information about the current stream.
 *
 * Returns information about the stream that has been parsed during decoding.
 *
 * \param[in]      ctx     Pointer to this instance's context
 * \param[in,out]  si      Pointer to stream info to update. The size member
 *                         \ref MUST be properly initialized, but \ref MAY be
 *                         clobbered by the algorithm. This parameter \ref MAY
 *                         be NULL.
 *
 * \retval #VPX_CODEC_OK
 *     Bitstream is parsable and stream information updated
 */
    pub fn vpx_codec_get_stream_info(ctx: *mut vpx_codec_ctx_t,
                                     si: *mut vpx_codec_stream_info_t)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Decode data
 *
 * Processes a buffer of coded data. If the processing results in a new
 * decoded frame becoming available, PUT_SLICE and PUT_FRAME events may be
 * generated, as appropriate. Encoded data \ref MUST be passed in DTS (decode
 * time stamp) order. Frames produced will always be in PTS (presentation
 * time stamp) order.
 * If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,
 * data and data_sz can contain a fragment of the encoded frame. Fragment
 * \#n must contain at least partition \#n, but can also contain subsequent
 * partitions (\#n+1 - \#n+i), and if so, fragments \#n+1, .., \#n+i must
 * be empty. When no more data is available, this function should be called
 * with NULL as data and 0 as data_sz. The memory passed to this function
 * must be available until the frame has been decoded.
 *
 * \param[in] ctx          Pointer to this instance's context
 * \param[in] data         Pointer to this block of new coded data. If
 *                         NULL, a VPX_CODEC_CB_PUT_FRAME event is posted
 *                         for the previously decoded frame.
 * \param[in] data_sz      Size of the coded data, in bytes.
 * \param[in] user_priv    Application specific data to associate with
 *                         this frame.
 * \param[in] deadline     Soft deadline the decoder should attempt to meet,
 *                         in us. Set to zero for unlimited.
 *
 * \return Returns #VPX_CODEC_OK if the coded data was processed completely
 *         and future pictures can be decoded without error. Otherwise,
 *         see the descriptions of the other error codes in ::vpx_codec_err_t
 *         for recoverability capabilities.
 */
    pub fn vpx_codec_decode(ctx: *mut vpx_codec_ctx_t, data: *const u8,
                            data_sz: ::std::os::raw::c_uint,
                            user_priv: *mut ::std::os::raw::c_void,
                            deadline: ::std::os::raw::c_long)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Decoded frames iterator
 *
 * Iterates over a list of the frames available for display. The iterator
 * storage should be initialized to NULL to start the iteration. Iteration is
 * complete when this function returns NULL.
 *
 * The list of available frames becomes valid upon completion of the
 * vpx_codec_decode call, and remains valid until the next call to
 * vpx_codec_decode.
 *
 * \param[in]     ctx      Pointer to this instance's context
 * \param[in,out] iter     Iterator storage, initialized to NULL
 *
 * \return Returns a pointer to an image, if one is ready for display. Frames
 *         produced will always be in PTS (presentation time stamp) order.
 */
    pub fn vpx_codec_get_frame(ctx: *mut vpx_codec_ctx_t,
                               iter: *mut vpx_codec_iter_t)
     -> *mut vpx_image_t;
}
/* \brief put frame callback prototype
 *
 * This callback is invoked by the decoder to notify the application of
 * the availability of decoded image data.
 */
pub type vpx_codec_put_frame_cb_fn_t =
    ::std::option::Option<unsafe extern "C" fn(user_priv:
                                                   *mut ::std::os::raw::c_void,
                                               img: *const vpx_image_t)>;
extern "C" {
    /* \brief Register for notification of frame completion.
 *
 * Registers a given function to be called when a decoded frame is
 * available.
 *
 * \param[in] ctx          Pointer to this instance's context
 * \param[in] cb           Pointer to the callback function
 * \param[in] user_priv    User's private data
 *
 * \retval #VPX_CODEC_OK
 *     Callback successfully registered.
 * \retval #VPX_CODEC_ERROR
 *     Decoder context not initialized, or algorithm not capable of
 *     posting slice completion.
 */
    pub fn vpx_codec_register_put_frame_cb(ctx: *mut vpx_codec_ctx_t,
                                           cb: vpx_codec_put_frame_cb_fn_t,
                                           user_priv:
                                               *mut ::std::os::raw::c_void)
     -> vpx_codec_err_t;
}
/* \brief put slice callback prototype
 *
 * This callback is invoked by the decoder to notify the application of
 * the availability of partially decoded image data. The
 */
pub type vpx_codec_put_slice_cb_fn_t =
    ::std::option::Option<unsafe extern "C" fn(user_priv:
                                                   *mut ::std::os::raw::c_void,
                                               img: *const vpx_image_t,
                                               valid: *const vpx_image_rect_t,
                                               update:
                                                   *const vpx_image_rect_t)>;
extern "C" {
    /* \brief Register for notification of slice completion.
 *
 * Registers a given function to be called when a decoded slice is
 * available.
 *
 * \param[in] ctx          Pointer to this instance's context
 * \param[in] cb           Pointer to the callback function
 * \param[in] user_priv    User's private data
 *
 * \retval #VPX_CODEC_OK
 *     Callback successfully registered.
 * \retval #VPX_CODEC_ERROR
 *     Decoder context not initialized, or algorithm not capable of
 *     posting slice completion.
 */
    pub fn vpx_codec_register_put_slice_cb(ctx: *mut vpx_codec_ctx_t,
                                           cb: vpx_codec_put_slice_cb_fn_t,
                                           user_priv:
                                               *mut ::std::os::raw::c_void)
     -> vpx_codec_err_t;
}
extern "C" {
    /* \brief Pass in external frame buffers for the decoder to use.
 *
 * Registers functions to be called when libvpx needs a frame buffer
 * to decode the current frame and a function to be called when libvpx does
 * not internally reference the frame buffer. This set function must
 * be called before the first call to decode or libvpx will assume the
 * default behavior of allocating frame buffers internally.
 *
 * \param[in] ctx          Pointer to this instance's context
 * \param[in] cb_get       Pointer to the get callback function
 * \param[in] cb_release   Pointer to the release callback function
 * \param[in] cb_priv      Callback's private data
 *
 * \retval #VPX_CODEC_OK
 *     External frame buffers will be used by libvpx.
 * \retval #VPX_CODEC_INVALID_PARAM
 *     One or more of the callbacks were NULL.
 * \retval #VPX_CODEC_ERROR
 *     Decoder context not initialized, or algorithm not capable of
 *     using external frame buffers.
 *
 * \note
 * When decoding VP9, the application may be required to pass in at least
 * #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS external frame
 * buffers.
 */
    pub fn vpx_codec_set_frame_buffer_functions(ctx: *mut vpx_codec_ctx_t,
                                                cb_get:
                                                    vpx_get_frame_buffer_cb_fn_t,
                                                cb_release:
                                                    vpx_release_frame_buffer_cb_fn_t,
                                                cb_priv:
                                                    *mut ::std::os::raw::c_void)
     -> vpx_codec_err_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
